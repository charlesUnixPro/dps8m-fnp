{\rtf1\ansi\ansicpg1252\cocoartf1343\cocoasubrtf160
{\fonttbl\f0\fswiss\fcharset0 ArialMT;\f1\froman\fcharset0 TimesNewRomanPSMT;\f2\fswiss\fcharset0 Helvetica;
\f3\ftech\fcharset77 Symbol;\f4\fmodern\fcharset0 CourierNewPSMT;\f5\fmodern\fcharset0 CourierNewPS-BoldMT;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue255;\red0\green128\blue0;\red163\green21\blue21;
\red191\green191\blue191;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid101\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid201\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid301\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid4}
{\list\listtemplateid5\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid401\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid402\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listname ;}\listid5}
{\list\listtemplateid6\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid501\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid502\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid503\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid6}
{\list\listtemplateid7\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid601\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid602\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid603\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid7}
{\list\listtemplateid8\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid701\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid702\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid703\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li2160\lin2160 }{\listname ;}\listid8}
{\list\listtemplateid9\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid801\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid802\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid803\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid9}
{\list\listtemplateid10\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid901\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid902\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid903\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid10}
{\list\listtemplateid11\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1001\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1002\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1003\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid11}
{\list\listtemplateid12\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1101\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1102\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1103\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid12}
{\list\listtemplateid13\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1201\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1202\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listname ;}\listid13}
{\list\listtemplateid14\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1301\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1302\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1303\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid14}
{\list\listtemplateid15\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1401\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1402\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1403\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid15}
{\list\listtemplateid16\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1501\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1502\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1503\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid16}
{\list\listtemplateid17\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1601\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1602\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1603\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li2160\lin2160 }{\listname ;}\listid17}
{\list\listtemplateid18\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1701\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1702\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1703\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li2160\lin2160 }{\listname ;}\listid18}
{\list\listtemplateid19\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1801\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1802\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1803\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid19}
{\list\listtemplateid20\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1901\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1902\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1903\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1904\'02\'03.;}{\levelnumbers\'01;}\fi-360\li2880\lin2880 }{\listname ;}\listid20}
{\list\listtemplateid21\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid2001\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid2002\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid2003\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li2160\lin2160 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid2004\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li2880\lin2880 }{\listname ;}\listid21}
{\list\listtemplateid22\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid2101\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid2102\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid2103\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid2104\'02\'03.;}{\levelnumbers\'01;}\fi-360\li2880\lin2880 }{\listname ;}\listid22}
{\list\listtemplateid23\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid2201\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid2202\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid2203\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid2204\'02\'03.;}{\levelnumbers\'01;}\fi-360\li2880\lin2880 }{\listname ;}\listid23}
{\list\listtemplateid24\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid2301\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid2302\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listname ;}\listid24}
{\list\listtemplateid25\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid2401\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid2402\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid2403\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid25}
{\list\listtemplateid26\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid2501\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid2502\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid2503\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li2160\lin2160 }{\listname ;}\listid26}
{\list\listtemplateid27\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid2601\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid2602\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid2603\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid27}
{\list\listtemplateid28\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid2701\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid2702\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid2703\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid28}
{\list\listtemplateid29\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid2801\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid2802\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid2803\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid29}
{\list\listtemplateid30\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid2901\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid2902\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid2903\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid30}
{\list\listtemplateid31\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3001\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3002\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3003\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid31}
{\list\listtemplateid32\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3101\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3102\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3103\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid32}
{\list\listtemplateid33\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3201\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3202\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3203\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid33}
{\list\listtemplateid34\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3301\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3302\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3303\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid34}
{\list\listtemplateid35\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3401\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3402\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3403\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid35}
{\list\listtemplateid36\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3501\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3502\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3503\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid36}
{\list\listtemplateid37\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3601\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3602\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3603\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid37}
{\list\listtemplateid38\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3701\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3702\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listname ;}\listid38}
{\list\listtemplateid39\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3801\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3802\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3803\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid39}
{\list\listtemplateid40\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3901\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3902\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3903\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid40}
{\list\listtemplateid41\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid4001\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid4002\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listname ;}\listid41}
{\list\listtemplateid42\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid4101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid4102\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listname ;}\listid42}
{\list\listtemplateid43\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid4201\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid4202\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid4203\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid43}
{\list\listtemplateid44\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid4301\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid4302\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listname ;}\listid44}
{\list\listtemplateid45\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid4401\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid4402\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listname ;}\listid45}
{\list\listtemplateid46\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid4501\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid4502\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid4503\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid46}
{\list\listtemplateid47\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid4601\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid4602\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid4603\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid47}
{\list\listtemplateid48\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid4701\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid4702\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid4703\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid48}
{\list\listtemplateid49\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid4801\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid4802\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid4803\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid49}
{\list\listtemplateid50\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid4901\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid4902\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid4903\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid50}
{\list\listtemplateid51\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid5001\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid5002\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listname ;}\listid51}
{\list\listtemplateid52\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid5101\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid5102\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listname ;}\listid52}
{\list\listtemplateid53\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid5201\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid5202\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listname ;}\listid53}
{\list\listtemplateid54\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid5301\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid5302\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listname ;}\listid54}
{\list\listtemplateid55\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid5401\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid5402\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listname ;}\listid55}
{\list\listtemplateid56\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid5501\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid5502\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid5503\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid56}
{\list\listtemplateid57\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid5601\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid5602\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid5603\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid57}
{\list\listtemplateid58\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid5701\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid5702\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid5703\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid58}
{\list\listtemplateid59\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid5801\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid5802\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid5803\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid59}
{\list\listtemplateid60\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid5901\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid5902\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid5903\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid60}
{\list\listtemplateid61\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid6001\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid6002\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid6003\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid61}
{\list\listtemplateid62\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid6101\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid6102\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listname ;}\listid62}
{\list\listtemplateid63\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid6201\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid6202\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listname ;}\listid63}
{\list\listtemplateid64\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid6301\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid6302\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listname ;}\listid64}
{\list\listtemplateid65\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid6401\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid6402\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listname ;}\listid65}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}{\listoverride\listid5\listoverridecount0\ls5}{\listoverride\listid6\listoverridecount0\ls6}{\listoverride\listid7\listoverridecount0\ls7}{\listoverride\listid8\listoverridecount0\ls8}{\listoverride\listid9\listoverridecount0\ls9}{\listoverride\listid10\listoverridecount0\ls10}{\listoverride\listid11\listoverridecount0\ls11}{\listoverride\listid12\listoverridecount0\ls12}{\listoverride\listid13\listoverridecount0\ls13}{\listoverride\listid14\listoverridecount0\ls14}{\listoverride\listid15\listoverridecount0\ls15}{\listoverride\listid16\listoverridecount0\ls16}{\listoverride\listid17\listoverridecount0\ls17}{\listoverride\listid18\listoverridecount0\ls18}{\listoverride\listid19\listoverridecount0\ls19}{\listoverride\listid20\listoverridecount0\ls20}{\listoverride\listid21\listoverridecount0\ls21}{\listoverride\listid22\listoverridecount0\ls22}{\listoverride\listid23\listoverridecount0\ls23}{\listoverride\listid24\listoverridecount0\ls24}{\listoverride\listid25\listoverridecount0\ls25}{\listoverride\listid26\listoverridecount0\ls26}{\listoverride\listid27\listoverridecount0\ls27}{\listoverride\listid28\listoverridecount0\ls28}{\listoverride\listid29\listoverridecount0\ls29}{\listoverride\listid30\listoverridecount0\ls30}{\listoverride\listid31\listoverridecount0\ls31}{\listoverride\listid32\listoverridecount0\ls32}{\listoverride\listid33\listoverridecount0\ls33}{\listoverride\listid34\listoverridecount0\ls34}{\listoverride\listid35\listoverridecount0\ls35}{\listoverride\listid36\listoverridecount0\ls36}{\listoverride\listid37\listoverridecount0\ls37}{\listoverride\listid38\listoverridecount0\ls38}{\listoverride\listid39\listoverridecount0\ls39}{\listoverride\listid40\listoverridecount0\ls40}{\listoverride\listid41\listoverridecount0\ls41}{\listoverride\listid42\listoverridecount0\ls42}{\listoverride\listid43\listoverridecount0\ls43}{\listoverride\listid44\listoverridecount0\ls44}{\listoverride\listid45\listoverridecount0\ls45}{\listoverride\listid46\listoverridecount0\ls46}{\listoverride\listid47\listoverridecount0\ls47}{\listoverride\listid48\listoverridecount0\ls48}{\listoverride\listid49\listoverridecount0\ls49}{\listoverride\listid50\listoverridecount0\ls50}{\listoverride\listid51\listoverridecount0\ls51}{\listoverride\listid52\listoverridecount0\ls52}{\listoverride\listid53\listoverridecount0\ls53}{\listoverride\listid54\listoverridecount0\ls54}{\listoverride\listid55\listoverridecount0\ls55}{\listoverride\listid56\listoverridecount0\ls56}{\listoverride\listid57\listoverridecount0\ls57}{\listoverride\listid58\listoverridecount0\ls58}{\listoverride\listid59\listoverridecount0\ls59}{\listoverride\listid60\listoverridecount0\ls60}{\listoverride\listid61\listoverridecount0\ls61}{\listoverride\listid62\listoverridecount0\ls62}{\listoverride\listid63\listoverridecount0\ls63}{\listoverride\listid64\listoverridecount0\ls64}{\listoverride\listid65\listoverridecount0\ls65}}
{\info
{\title Writing a Simulator for the SIMH System}
{\author Bob Supnik}
{\*\company Digital Equipment Corporation}}\margl1440\margr1440\vieww12540\viewh16140\viewkind1
\deftab720
\pard\pardeftab720\li720\fi-720\ri0\qc

\f0\b\fs32 \cf0 Writing a Simulator for the SIMH System\
\pard\pardeftab720\ri0\qc
\cf0 Revised 1415-MayApr-20143 for SIMH V4.0\
\pard\pardeftab720\ri0

\f1\fs20 \cf0 \
\
\pard\pardeftab720\ri0

\f0 \cf0 COPYRIGHT NOTICE\
\pard\pardeftab720\ri0

\f1\b0 \cf0 \
\pard\pardeftab720\ri0

\f0 \cf0 The following copyright notice applies to the SIMH source, binary, and documentation:\
\
\pard\pardeftab720\li720\ri962
\cf0 Original code published in 1993-2008, written by Robert M Supnik\
Copyright (c) 1993-2008, Robert M Supnik\
\
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\
\
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\
\
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL ROBERT M SUPNIK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  SOFTWARE.\
\
Except as contained in this notice, the name of Robert M Supnik shall not be used in advertising or otherwise to promote the sale, use or other dealings in this Software without prior written authorization from Robert M Supnik.\
\pard\pardeftab720\ri0

\f1 \cf0 \
\page \pard\pardeftab720\ri0

\f0 \cf0 \
\pard\tx600\tqr\tx9350\pardeftab720\ri0\sb120

\f1\i\b\fs24 \cf0 1.
\f2\i0\b0\fs22 	
\f1\i\b\fs24 Overview	4
\f2\i0\b0\fs22 \

\f1\i\b\fs24 2.
\f2\i0\b0\fs22 	
\f1\i\b\fs24 Data Types	4
\f2\i0\b0\fs22 \

\f1\i\b\fs24 3.
\f2\i0\b0\fs22 	
\f1\i\b\fs24 VM Organization	5
\f2\i0\b0\fs22 \
\pard\tx800\tqr\tx9350\pardeftab720\li200\ri0\sb120

\f1\b \cf0 3.1
\f2\b0 	
\f1\b CPU Organization	6
\f2\b0 \
\pard\tx1200\tqr\tx9350\pardeftab720\li400\ri0

\f1\fs20 \cf0 3.1.1
\f2\fs22 	
\f1\fs20 Time Base	6
\f2\fs22 \

\f1\fs20 3.1.2
\f2\fs22 	
\f1\fs20 Step Function	6
\f2\fs22 \

\f1\fs20 3.1.3
\f2\fs22 	
\f1\fs20 Memory Organization	7
\f2\fs22 \

\f1\fs20 3.1.4
\f2\fs22 	
\f1\fs20 Interrupt Organization	7
\f2\fs22 \

\f1\fs20 3.1.5
\f2\fs22 	
\f1\fs20 I/O Dispatching	8
\f2\fs22 \

\f1\fs20 3.1.6
\f2\fs22 	
\f1\fs20 Instruction Execution	8
\f2\fs22 \
\pard\tx800\tqr\tx9350\pardeftab720\li200\ri0\sb120

\f1\b \cf0 3.2
\f2\b0 	
\f1\b Peripheral Device Organization	9
\f2\b0 \
\pard\tx1200\tqr\tx9350\pardeftab720\li400\ri0

\f1\fs20 \cf0 3.2.1
\f2\fs22 	
\f1\fs20 Device Timing	10
\f2\fs22 \

\f1\fs20 3.2.2
\f2\fs22 	
\f1\fs20 Clock Calibration	11
\f2\fs22 \

\f1\fs20 3.2.3
\f2\fs22 	
\f1\fs20 Idling	11
\f2\fs22 \

\f1\fs20 3.2.4
\f2\fs22 	
\f1\fs20 Data I/O	12
\f2\fs22 \
\pard\tx600\tqr\tx9350\pardeftab720\ri0\sb120

\f1\i\b\fs24 \cf0 4.
\f2\i0\b0\fs22 	
\f1\i\b\fs24 Data Structures	13
\f2\i0\b0\fs22 \
\pard\tx800\tqr\tx9350\pardeftab720\li200\ri0\sb120

\f1\b \cf0 4.1
\f2\b0 	
\f1\b sim_device Structure	13
\f2\b0 \
\pard\tx1200\tqr\tx9350\pardeftab720\li400\ri0

\f1\fs20 \cf0 4.1.1
\f2\fs22 	
\f1\fs20 Awidth and Aincr	15
\f2\fs22 \

\f1\fs20 4.1.2
\f2\fs22 	
\f1\fs20 Device Flags	15
\f2\fs22 \

\f1\fs20 4.1.3
\f2\fs22 	
\f1\fs20 Context	15
\f2\fs22 \

\f1\fs20 4.1.4
\f2\fs22 	
\f1\fs20 Examine and Deposit Routines	15
\f2\fs22 \

\f1\fs20 4.1.5
\f2\fs22 	
\f1\fs20 Reset Routine	16
\f2\fs22 \

\f1\fs20 4.1.6
\f2\fs22 	
\f1\fs20 Boot Routine	16
\f2\fs22 \

\f1\fs20 4.1.7
\f2\fs22 	
\f1\fs20 Attach and Detach Routines	16
\f2\fs22 \

\f1\fs20 4.1.8
\f2\fs22 	
\f1\fs20 Memory Size Change Routine	17
\f2\fs22 \

\f1\fs20 4.1.9
\f2\fs22 	
\f1\fs20 Debug Controls	17
\f2\fs22 \

\f1\fs20 4.1.10
\f2\fs22 	
\f1\fs20 Device Specific Help support	18
\f2\fs22 \

\f1\fs20 4.1.11
\f2\fs22 	
\f1\fs20 Help Routine	18
\f2\fs22 \

\f1\fs20 4.1.12
\f2\fs22 	
\f1\fs20 Attach Help Routine	19
\f2\fs22 \
\pard\tx800\tqr\tx9350\pardeftab720\li200\ri0\sb120

\f1\b \cf0 4.2
\f2\b0 	
\f1\b sim_unit Structure	19
\f2\b0 \
\pard\tx1200\tqr\tx9350\pardeftab720\li400\ri0

\f1\fs20 \cf0 4.2.1
\f2\fs22 	
\f1\fs20 Unit Flags	20
\f2\fs22 \

\f1\fs20 4.2.2
\f2\fs22 	
\f1\fs20 Service Routine	20
\f2\fs22 \
\pard\tx800\tqr\tx9350\pardeftab720\li200\ri0\sb120

\f1\b \cf0 4.3
\f2\b0 	
\f1\b sim_reg Structure	20
\f2\b0 \
\pard\tx1200\tqr\tx9350\pardeftab720\li400\ri0

\f1\fs20 \cf0 4.3.1
\f2\fs22 	
\f1\fs20 Register Flags	22
\f2\fs22 \
\pard\tx800\tqr\tx9350\pardeftab720\li200\ri0\sb120

\f1\b \cf0 4.4
\f2\b0 	
\f1\b sim_bitfield Structure	22
\f2\b0 \

\f1\b 4.5
\f2\b0 	
\f1\b sim_mtab Structure	23
\f2\b0 \
\pard\tx1200\tqr\tx9350\pardeftab720\li400\ri0

\f1\fs20 \cf0 4.5.1
\f2\fs22 	
\f1\fs20 Validation Routine	25
\f2\fs22 \

\f1\fs20 4.5.2
\f2\fs22 	
\f1\fs20 Display Routine	25
\f2\fs22 \

\f1\fs20 4.5.3
\f2\fs22 	
\f1\fs20 Help Flags	25
\f2\fs22 \

\f1\fs20 4.5.4
\f2\fs22 	
\f1\fs20 Example arguments in the 
\b mstring
\b0 	26
\f2\fs22 \

\f1\fs20 4.5.5
\f2\fs22 	
\f1\fs20 Help field	26
\f2\fs22 \
\pard\tx800\tqr\tx9350\pardeftab720\li200\ri0\sb120

\f1\b \cf0 4.6
\f2\b0 	
\f1\b Other Data Structures	26
\f2\b0 \
\pard\tx600\tqr\tx9350\pardeftab720\ri0\sb120

\f1\i\b\fs24 \cf0 5.
\f2\i0\b0\fs22 	
\f1\i\b\fs24 VM Provided Routines	26
\f2\i0\b0\fs22 \
\pard\tx800\tqr\tx9350\pardeftab720\li200\ri0\sb120

\f1\b \cf0 5.1
\f2\b0 	
\f1\b Instruction Execution	26
\f2\b0 \

\f1\b 5.2
\f2\b0 	
\f1\b Binary Load and Dump	27
\f2\b0 \

\f1\b 5.3
\f2\b0 	
\f1\b Symbolic Examination and Deposit	27
\f2\b0 \

\f1\b 5.4
\f2\b0 	
\f1\b Optional Interfaces	28
\f2\b0 \
\pard\tx1200\tqr\tx9350\pardeftab720\li400\ri0

\f1\fs20 \cf0 5.4.1
\f2\fs22 	
\f1\fs20 Once Only Initialization Routine	28
\f2\fs22 \

\f1\fs20 5.4.2
\f2\fs22 	
\f1\fs20 Address Input and Display	28
\f2\fs22 \

\f1\fs20 5.4.3
\f2\fs22 	
\f1\fs20 Command Input and Post-Processing	28
\f2\fs22 \

\f1\fs20 5.4.4
\f2\fs22 	
\f1\fs20 VM-Specific Commands	29
\f2\fs22 \

\f1\fs20 5.4.5
\f2\fs22 	
\f1\fs20 VM-Support for stepping over subroutine calls	29
\f2\fs22 \
\pard\tx600\tqr\tx9350\pardeftab720\ri0\sb120

\f1\i\b\fs24 \cf0 6.
\f2\i0\b0\fs22 	
\f1\i\b\fs24 Other SCP Facilities	29
\f2\i0\b0\fs22 \
\pard\tx800\tqr\tx9350\pardeftab720\li200\ri0\sb120

\f1\b \cf0 6.1
\f2\b0 	
\f1\b Terminal Input/Output Formatting Library	29
\f2\b0 \

\f1\b 6.2
\f2\b0 	
\f1\b Terminal Multiplexer Emulation Library	30
\f2\b0 \

\f1\b 6.3
\f2\b0 	
\f1\b Magnetic Tape Emulation Library	35
\f2\b0 \

\f1\b 6.4
\f2\b0 	
\f1\b Disk Emulation Library	37
\f2\b0 \

\f1\b 6.5
\f2\b0 	
\f1\b Breakpoint Support	38
\f2\b0 \
\pard\pardeftab720\ri0

\f1\fs20 \cf0 1.
\f2\i\b\fs22 	
\f1\i0\b0\fs20 Overview	4
\f2\i\b\fs22 \

\f1\i0\b0\fs20 2.
\f2\i\b\fs22 	
\f1\i0\b0\fs20 Data Types	4
\f2\i\b\fs22 \

\f1\i0\b0\fs20 3.
\f2\i\b\fs22 	
\f1\i0\b0\fs20 VM Organization	5
\f2\i\b\fs22 \

\f1\i0\b0\fs20 3.1
\f2\b 	
\f1\b0 CPU Organization	6
\f2\b \

\f1\b0 3.1.1
\f2\fs22 	
\f1\fs20 Time Base	6
\f2\fs22 \

\f1\fs20 3.1.2
\f2\fs22 	
\f1\fs20 Step Function	6
\f2\fs22 \

\f1\fs20 3.1.3
\f2\fs22 	
\f1\fs20 Memory Organization	7
\f2\fs22 \

\f1\fs20 3.1.4
\f2\fs22 	
\f1\fs20 Interrupt Organization	7
\f2\fs22 \

\f1\fs20 3.1.5
\f2\fs22 	
\f1\fs20 I/O Dispatching	8
\f2\fs22 \

\f1\fs20 3.1.6
\f2\fs22 	
\f1\fs20 Instruction Execution	8
\f2\fs22 \

\f1\fs20 3.2
\f2\b 	
\f1\b0 Peripheral Device Organization	9
\f2\b \

\f1\b0 3.2.1
\f2\fs22 	
\f1\fs20 Device Timing	10
\f2\fs22 \

\f1\fs20 3.2.2
\f2\fs22 	
\f1\fs20 Clock Calibration	11
\f2\fs22 \

\f1\fs20 3.2.3
\f2\fs22 	
\f1\fs20 Idling	11
\f2\fs22 \

\f1\fs20 3.2.4
\f2\fs22 	
\f1\fs20 Data I/O	12
\f2\fs22 \

\f1\fs20 4.
\f2\i\b\fs22 	
\f1\i0\b0\fs20 Data Structures	13
\f2\i\b\fs22 \

\f1\i0\b0\fs20 4.1
\f2\b 	
\f1\b0 sim_device Structure	13
\f2\b \

\f1\b0 4.1.1
\f2\fs22 	
\f1\fs20 Awidth and Aincr	15
\f2\fs22 \

\f1\fs20 4.1.2
\f2\fs22 	
\f1\fs20 Device Flags	15
\f2\fs22 \

\f1\fs20 4.1.3
\f2\fs22 	
\f1\fs20 Context	15
\f2\fs22 \

\f1\fs20 4.1.4
\f2\fs22 	
\f1\fs20 Examine and Deposit Routines	15
\f2\fs22 \

\f1\fs20 4.1.5
\f2\fs22 	
\f1\fs20 Reset Routine	16
\f2\fs22 \

\f1\fs20 4.1.6
\f2\fs22 	
\f1\fs20 Boot Routine	16
\f2\fs22 \

\f1\fs20 4.1.7
\f2\fs22 	
\f1\fs20 Attach and Detach Routines	16
\f2\fs22 \

\f1\fs20 4.1.8
\f2\fs22 	
\f1\fs20 Memory Size Change Routine	17
\f2\fs22 \

\f1\fs20 4.1.9
\f2\fs22 	
\f1\fs20 Debug Controls	17
\f2\fs22 \

\f1\fs20 4.1.10
\f2\fs22 	
\f1\fs20 Device Specific Help support	18
\f2\fs22 \

\f1\fs20 4.1.11
\f2\fs22 	
\f1\fs20 Help Routine	18
\f2\fs22 \

\f1\fs20 4.1.12
\f2\fs22 	
\f1\fs20 Attach Help Routine	19
\f2\fs22 \

\f1\fs20 4.2
\f2\b 	
\f1\b0 sim_unit Structure	19
\f2\b \

\f1\b0 4.2.1
\f2\fs22 	
\f1\fs20 Unit Flags	20
\f2\fs22 \

\f1\fs20 4.2.2
\f2\fs22 	
\f1\fs20 Service Routine	20
\f2\fs22 \

\f1\fs20 4.3
\f2\b 	
\f1\b0 sim_reg Structure	20
\f2\b \

\f1\b0 4.3.1
\f2\fs22 	
\f1\fs20 Register Flags	22
\f2\fs22 \

\f1\fs20 4.4
\f2\b 	
\f1\b0 sim_bitfield Structure	22
\f2\b \

\f1\b0 4.5
\f2\b 	
\f1\b0 sim_mtab Structure	23
\f2\b \

\f1\b0 4.5.1
\f2\fs22 	
\f1\fs20 Validation Routine	25
\f2\fs22 \

\f1\fs20 4.5.2
\f2\fs22 	
\f1\fs20 Display Routine	25
\f2\fs22 \

\f1\fs20 4.5.3
\f2\fs22 	
\f1\fs20 Help Flags	25
\f2\fs22 \

\f1\fs20 4.5.4
\f2\fs22 	
\f1\fs20 Example arguments in the 
\b mstring
\b0 	26
\f2\fs22 \

\f1\fs20 4.5.5
\f2\fs22 	
\f1\fs20 Help field	26
\f2\fs22 \

\f1\fs20 4.6
\f2\b 	
\f1\b0 Other Data Structures	26
\f2\b \

\f1\b0 5.
\f2\i\b\fs22 	
\f1\i0\b0\fs20 VM Provided Routines	26
\f2\i\b\fs22 \

\f1\i0\b0\fs20 5.1
\f2\b 	
\f1\b0 Instruction Execution	26
\f2\b \

\f1\b0 5.2
\f2\b 	
\f1\b0 Binary Load and Dump	27
\f2\b \

\f1\b0 5.3
\f2\b 	
\f1\b0 Symbolic Examination and Deposit	27
\f2\b \

\f1\b0 5.4
\f2\b 	
\f1\b0 Optional Interfaces	28
\f2\b \

\f1\b0 5.4.1
\f2\fs22 	
\f1\fs20 Once Only Initialization Routine	28
\f2\fs22 \

\f1\fs20 5.4.2
\f2\fs22 	
\f1\fs20 Address Input and Display	28
\f2\fs22 \

\f1\fs20 5.4.3
\f2\fs22 	
\f1\fs20 Command Input and Post-Processing	28
\f2\fs22 \

\f1\fs20 5.4.4
\f2\fs22 	
\f1\fs20 VM-Specific Commands	29
\f2\fs22 \

\f1\fs20 6.
\f2\i\b\fs22 	
\f1\i0\b0\fs20 Other SCP Facilities	29
\f2\i\b\fs22 \

\f1\i0\b0\fs20 6.1
\f2\b 	
\f1\b0 Terminal Input/Output Formatting Library	29
\f2\b \

\f1\b0 6.2
\f2\b 	
\f1\b0 Terminal Multiplexer Emulation Library	30
\f2\b \

\f1\b0 6.3
\f2\b 	
\f1\b0 Magnetic Tape Emulation Library	35
\f2\b \

\f1\b0 6.4
\f2\b 	
\f1\b0 Disk Emulation Library	36
\f2\b \

\f1\b0 6.5
\f2\b 	
\f1\b0 Breakpoint Support	38
\f2\b \
\pard\pardeftab720\ri0

\f0\b0 \cf0 \
\page \
\pard\tx360\pardeftab720\li360\fi-360\ri0\sb240\sa60
\ls1\ilvl0
\b\fs28 \cf0 1.	Overview\
\pard\pardeftab720\ri0

\b0\fs20 \cf0 \
SIMH (history simulators) is a set of portable programs, written in C, which simulate various historically interesting computers.  This document describes how to design, write, and check out a new simulator for SIMH.  It is not an introduction to either the philosophy or external operation of SIMH, and the reader should be familiar with both of those topics before proceeding.  Nor is it a guide to the internal design or operation of SIMH, except insofar as those areas interact with simulator design.  Instead, this manual presents and explains the form, meaning, and operation of the interfaces between simulators and the SIMH simulator control package.  It also offers some suggestions for utilizing the services SIMH offers and explains the constraints that all simulators operating within SIMH will experience.\
\
Some terminology: Each simulator consists of a standard 
\i simulator control package
\i0  (SCP and related libraries), which provides a control framework and utility routines for a simulator; and a unique 
\i virtual machine
\i0  (VM), which implements the simulated processor and selected peripherals.  A VM consists of multiple 
\i devices
\i0 , such as the CPU, paper tape reader, disk controller, etc.  Each controller consists of a named state space (called 
\i registers
\i0 ) and one or more 
\i units
\i0 .  Each unit consists of a numbered state space (called a 
\i data set
\i0 ). 
\i  
\i0 The 
\i host computer
\i0  is the system on which SIMH runs; the 
\i target computer
\i0  is the system being simulated.\
\
SIMH is unabashedly based on the MIMIC simulation system, designed in the late 1960\'92s by Len Fehskens, Mike McCarthy, and Bob Supnik.   This document is based on MIMIC\'92s published interface specification, \'93How to Write a Virtual Machine for the MIMIC Simulation System\'94, by Len Fehskens and Bob Supnik.\
\
\pard\tx360\pardeftab720\li360\fi-360\ri0\sb240\sa60
\ls2\ilvl0
\b\fs28 \cf0 2.	Data Types\
\pard\pardeftab720\ri0

\b0\fs20 \cf0 \
SIMH is written in C.  The host system must support (at least) 32-bit data types (64-bit data types for the PDP-10 and other large-word target systems).  To cope with the vagaries of C data types, SIMH defines some unambiguous data types for its interfaces:\
\
	SIMH data type			interpretation in typical 32-bit C\
\
	int8, uint8			signed char, unsigned char\
	int16, uint16			signed short, unsigned short\
	int32, uint32			signed int, unsigned int\
	t_int64, t_uint64			long long, _int64 (system specific)\
	t_addr				simulated address, uint32 or t_uint64\
	t_value				simulated value, uint32 or t_uint64\
	t_svalue			simulated signed value, int32 or t_int64\
	t_mtrec				mag tape record length, uint32\
	t_stat				status code, int\
	t_bool				true/false value, int\
\
[The inconsistency in naming t_int64 and t_uint64 is due to Microsoft VC++, which uses int64 as a structure name member in the master Windows definitions file.]\
\
In addition, SIMH defines structures for each of its major data elements:\
\
	
\b DEVICE
\b0 			device definition structure\
	
\b UNIT
\b0 				unit definition structure\
	
\b REG
\b0 				register definition structure\
	
\b MTAB
\b0 				modifier definition structure\
	
\b CTAB
\b0 				command definition structure\
	
\b DEBTAB
\b0 			debug table entry structure\
\
\pard\tx360\pardeftab720\li360\fi-360\ri0\sb240\sa60
\ls3\ilvl0
\b\fs28 \cf0 3.	VM Organization\
\pard\pardeftab720\ri0

\b0\fs20 \cf0 \
A virtual machine (VM) is a collection of devices bound together through their internal logic.  Each device is named and corresponds more or less to a hunk of hardware on the real machine; for example:\
\
	VM device			Real machine hardware\
\
	CPU				central processor and main memory\
	PTR				paper tape reader controller and paper tape reader\
	TTI				console keyboard\
	TTO				console output\
	DKP				disk pack controller and drives\
\
There may be more than one device per physical hardware entity, as for the console; but for each user-accessible device there must be at least one.  One of these devices will have the pre-eminent responsibility for directing simulated operations.  Normally, this is the CPU, but it could be a higher-level entity, such as a bus master.\
\
The VM actually runs as a subroutine of the simulator control package (SCP).  It provides a master routine for running simulated programs and other routines and data structures to implement SCP\'92s command and control functions.  The interfaces between a VM and SCP are relatively few:\
\
	Interface			Function\
\
	char 
\b sim_name[]
\b0 		simulator name string\
	REG *
\b sim_pc
\b0 			pointer to simulated program counter\
	int32 
\b sim_emax
\b0 		maximum number of words in an instruction\
	DEVICE *
\b sim_devices[]
\b0 	table of pointers to simulated devices, NULL terminated\
	char *
\b sim_stop_messages[]
\b0 	table of pointers to error messages\
	t_stat 
\b sim_load
\b0  (\'85)		binary loader subroutine\
	t_stat 
\b sim_inst
\b0  (void)		instruction execution subroutine\
	t_stat 
\b parse_sym
\b0  (\'85)		symbolic instruction parse subroutine\
	t_stat 
\b fprint_sym
\b0  (\'85)		symbolic instruction print subroutine\
\
In addition, there are six optional interfaces, which can be used for special situations, such as GUI implementations:\
\
	Interface				Function\
\
	void (*
\b sim_vm_init
\b0 ) (void)		pointer to once-only initialization routine for VM\
	t_addr (*
\b sim_vm_parse_addr
\b0 ) (\'85)	pointer to address parsing routine\
	void (*
\b sim_vm_fprint_addr
\b0 ) (\'85)	pointer to address output routine\
	char (
\b *sim_vm_read
\b0 ) (\'85)		pointer to command input routine\
	void (*
\b sim_vm_post
\b0 ) (\'85)		pointer to command post-processing routine\
	CTAB 
\b *sim_vm_cmd
\b0 			pointer to simulator-specific command table\
\
There is no required organization for VM code.  The following convention has been used so far.  Let name be the 
\i name
\i0  of the real system (i1401 for the IBM 1401; i1620 for the IBM 1620; pdp1 for the PDP-1; pdp18b for the other 18-bit PDP\'92s; pdp8 for the PDP-8; pdp11 for the PDP-11; nova for Nova; hp2100 for the HP 21XX; h316 for the Honeywell 315/516; gri for the GRI-909; pdp10 for the PDP-10; vax for the VAX; sds for the SDS-940):\
\
\pard\tx720\pardeftab720\li720\fi-360\ri0
\ls4\ilvl0
\i \cf0 name
\i0 .h contains definitions for the particular simulator\
\ls4\ilvl0
\i name
\i0 _sys.c contains all the SCP interfaces except the instruction simulator\
\ls4\ilvl0
\i name
\i0 _cpu.c contains the instruction simulator and CPU data structures\
\ls4\ilvl0
\i name
\i0 _stddev.c contains the peripherals which were standard with the real system.\
\ls4\ilvl0
\i name
\i0 _lp.c contains the line printer.\
\ls4\ilvl0
\i name
\i0 _mt.c contains the mag tape controller and drives, etc.\
\pard\pardeftab720\fi1440\ri0
\cf0 \
\pard\pardeftab720\ri0
\cf0 The SIMH standard definitions are in sim_defs.h.  The base components of SIMH are:\
\
	Source module		header file		module\
\
	scp.c			scp.h			control package\
	sim_console.c		sim_console.h		terminal I/O library\
	sim_fio.c		sim_fio.h		file I/O library\
	sim_timer.c		sim_timer.h		timer library\
	sim_sock.c		sim_sock.h		socket I/O library\
	sim_ether.c		sim_ether.h		Ethernet I/O library\
	sim_serial.c		sim_serial.h		Serial Port I/O library\
	sim_tmxr.c		sim_tmxr.h		terminal multiplexer simulation library\
	sim_disk.c		sim_disk.h		disk simulation library\
	sim_tape.c		sim_tape.h		magtape simulation library\
\pard\tx390\pardeftab720\li390\fi-390\ri0\sb240\sa60
\ls5\ilvl1
\i\b\fs24 \cf0 3.1	CPU Organization\
\pard\pardeftab720\ri0

\i0\b0\fs20 \cf0 \
Most CPU\'92s perform at least the following functions:\
\
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 Time keeping\
Instruction fetching\
Address decoding\
Execution of non-I/O instructions\
I/O command processing\
Interrupt processing\
\pard\pardeftab720\ri0
\cf0 \
Instruction execution is actually the least complicated part of the design; memory and I/O organization should be tackled first.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls6\ilvl2
\fs24 \cf0 3.1.1	Time Base\
\pard\pardeftab720\ri0

\fs20 \cf0 \
In order to simulate asynchronous events, such as I/O completion, the VM must define and keep a time base.  This can be accurate (for example, nanoseconds of execution) or arbitrary (for example, number of instructions executed), but it must be used consistently throughout the VM.  All existing VM\'92s count time in instructions.\
\
The CPU is responsible for counting down the event counter 
\b sim_interval
\b0  and calling the asynchronous event controller 
\b sim_process_event
\b0 .  SCP does the record keeping for timing.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls7\ilvl2
\fs24 \cf0 3.1.2	Step Function\
\pard\pardeftab720\ri0

\fs20 \cf0 \
SCP implements a stepping function using the step command.  STEP counts down a specified number of time units (as described in section 3.1.1) and then stops simulation.  The VM can override the STEP command\'92s counts by calling routine 
\b sim_cancel_step
\b0 :\
\
\pard\tx720\pardeftab720\li720\fi-360\ri0
\ls8\ilvl2
\f3 \cf0 \'a5	
\f0 t_stat sim_cancel_step (void) \'96 cancel STEP count down.\
\pard\pardeftab720\ri0
\cf0 \
The VM can then inspect variable 
\b sim_step
\b0  to see if a STEP command is in progress.  If 
\b sim_step
\b0  is non-zero, it represents the number of steps to execute.  The VM can count down 
\b sim_step
\b0  using its own counting method, such as cycles, instructions, or memory references.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls9\ilvl2
\fs24 \cf0 3.1.3	Memory Organization\
\pard\pardeftab720\ri0

\fs20 \cf0 \
The criterion for memory layout is very simple: use the SIMH data type that is as large as (or if necessary, larger than), the word length of the real machine.  Note that the criterion is word length, not addressability: the PDP-11 has byte addressable memory, but it is a 16-bit machine, and its memory is defined as uint16 M[].  It may seem tempting to define memory as a union of int8 and int16 data types, but this would make the resulting VM endian-dependent.  Instead, the VM should be based on the underlying word size of the real machine, and byte manipulation should be done explicitly.  Examples:\
\
	Simulator		memory size		memory declaration\
\
	IBM 1620		5-bit			uint8\
	IBM 1401		7-bit			uint8\
	PDP-8			12-bit			uint16\
	PDP-11, Nova		16-bit			uint16\
	PDP-1			18-bit			uint32\
	VAX			32-bit			uint32\
	PDP-10, IBM 7094	36-bit			t_uint64\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls10\ilvl2
\fs24 \cf0 3.1.4	Interrupt Organization\
\pard\pardeftab720\ri0

\fs20 \cf0 \
The design of the VM\'92s interrupt structure is a complex interaction between efficiency and fidelity to the hardware.  If the VM\'92s interrupt structure is too abstract, interrupt driven software may not run.  On the other hand, if it follows the hardware too literally, it may significantly reduce simulation speed.  One rule I can offer is to minimize the fetch-phase cost of interrupts, even if this complicates the (much less frequent) evaluation of the interrupt system following an I/O operation or asynchronous event.  Another is not to over-generalize; even if the real hardware could support 64 or 256 interrupting devices, the simulators will be running much smaller configurations.  I\'92ll start with a simple interrupt structure and then offer suggestions for generalization.\
\
In the simplest structure, interrupt requests correspond to device flags and are kept in an interrupt request variable, with one flag per bit.  The fetch-phase evaluation of interrupts consists of two steps: are interrupts enabled, and is there an interrupt outstanding?  If all the interrupt requests are kept as single-bit flags in a variable, the fetch-phase test is very fast:\
\
	if (int_enable && int_requests) \{ \'85process interrupt\'85 \}\
\
Indeed, the interrupt enable flag can be made the highest bit in the interrupt request variable, and the two tests combined:\
\
	if (int_requests > INT_ENABLE) \{ \'85process interrupt\'85 \}\
\
Setting or clearing device flags directly sets or clears the appropriate interrupt request flag:\
\
	set: 	int_requests = int_requests | DEVICE_FLAG;\
	clear:	int_requests = int_requests & ~DEVICE_FLAG;\
\
At a slightly higher complexity, interrupt requests do not correspond directly to device flags but are based on masking the device flags with an enable (or disable) mask.  There are now two parallel variables: device flags and interrupt enable mask.  The fetch-phase test is now:\
\
	If (int_enable && (dev_flags & int_enables)) \{ \'85process interrupt\'85 \}\
\
As a next step, the VM may keep a summary interrupt request variable, which is updated by any change to a device flag or interrupt enable/disable:\
\
	enable:	int_requests = device_flags & int_enables;\
	disable:	int_requests = device_flags & ~int_disables;\
\
This simplifies the fetch phase test slightly.\
\
At yet higher complexity, the interrupt system may be too complex or too large to evaluate during the fetch-phase.  In this case, an interrupt pending flag is created, and it is evaluated by subroutine call whenever a change could occur (start of execution, I/O instruction issued, device time out occurs).  This makes fetch-phase evaluation simple and isolates interrupt evaluation to a common subroutine.\
\
If required for interrupt processing, the highest priority interrupting device can be determined by scanning the interrupt request variable from high priority to low until a set bit is found.  The bit position can then be back-mapped through a table to determine the address or interrupt vector of the interrupting device.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls11\ilvl2
\fs24 \cf0 3.1.5	I/O Dispatching\
\pard\pardeftab720\ri0

\fs20 \cf0 \
I/O dispatching consists of four steps:\
\
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 Identify the I/O command and analyze for the device address.\
Locate the selected device.\
Break down the I/O command into standard fields.\
Call the device processor.\
\pard\pardeftab720\ri0
\cf0 \
Analyzing an I/O command is usually easy.  Most systems have one or more explicit I/O instructions containing an I/O command and a device address.  Memory mapped I/O is more complicated; the identification of a reference to I/O space becomes part of memory addressing.  This usually requires centralizing memory reads and writes into subroutines, rather than as inline code.\
\
Once an I/O command has been analyzed, the CPU must locate the device subroutine.  The simplest way is a large switch statement with hardwired subroutine calls. More modular is to call through a dispatch table, with NULL entries representing non-existent devices; this also simplifies support for modifiable device addresses and configurable devices.  Before calling the device routine, the CPU usually breaks down the I/O command into standard fields.  This simplifies writing the peripheral simulator.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls12\ilvl2
\fs24 \cf0 3.1.6	Instruction Execution\
\pard\pardeftab720\ri0

\fs20 \cf0 \
Instruction execution is the responsibility of VM subroutine 
\b sim_instr
\b0 .  It is called from SCP as a result of a RUN, GO, CONT, or BOOT command.  It begins executing instructions at the current PC (
\b sim_PC
\b0  points to its register description block) and continues until halted by an error or an external event.\
\
When called, the CPU needs to account for any state changes that the user made.  For example, it may need to re-evaluate whether an interrupt is pending, or restore frequently used state to local register variables for efficiency.  The actual instruction fetch and execute cycle is usually structured as a loop controlled by an error variable, e.g.,\
\
	reason = 0;\
	do \{ \'85 \} while (reason == 0);	or	while (reason == 0) \{ \'85 \}\
\
Within this loop, the usual order of events is:\
\
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 If the event timer 
\b sim_interval
\b0  has reached zero, process any timed events.  This is done by SCP subroutine 
\b sim_process_event
\b0 .  Because this is the polling mechanism for user-generated processor halts (^E), errors must be recognized immediately:\
\pard\pardeftab720\ri0
\cf0 \
\pard\pardeftab720\li1440\ri0
\cf0 if (sim_interval <= 0) \{\
\pard\pardeftab720\li1440\fi720\ri0
\cf0 if (reason = sim_process_event ()) break;  \}\
\pard\pardeftab720\fi2160\ri0
\cf0 \
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 Check for outstanding interrupts and process if required.\
\pard\pardeftab720\ri0
\cf0 \
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 Check for other processor-unique events, such as wait-state outstanding or traps outstanding.\
\pard\pardeftab720\ri0
\cf0 \
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 Check for an instruction breakpoint.  SCP has a comprehensive breakpoint facility.  It allows a VM to define many different kinds of breakpoints.  The VM checks for execution (type E) breakpoints during instruction fetch.\
\pard\pardeftab720\ri0
\cf0 \
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 Fetch the next instruction, increment the PC, optionally decode the address, and dispatch (via a switch statement) for execution.\
\pard\pardeftab720\ri0
\cf0 \
A few guidelines for implementation:\
\
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 In general, code should reflect the hardware being simulated.  This is usually simplest and easiest to debug.\
\pard\pardeftab720\ri0
\cf0 \
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 The VM should provide some debugging aids.  The existing CPU\'92s all provide multiple instruction breakpoints, a PC change queue, error stops on invalid instructions or operations, and symbolic examination and modification of memory.\
\pard\tx390\pardeftab720\li390\fi-390\ri0\sb240\sa60
\ls13\ilvl1
\i\b\fs24 \cf0 3.2	Peripheral Device Organization\
\pard\pardeftab720\ri0

\i0\b0\fs20 \cf0 \
The basic elements of a VM are devices, each corresponding roughly to a real chunk of hardware.  A device consists of register-based state and one or more units.  Thus, a multi-drive disk subsystem is a single device (representing the hardware of the real controller) and one or more units (each representing a single disk drive).  Sometimes the device and its unit are the same entity as, for example, in the case of a paper tape reader.  However, a single physical device, such as the console, may be broken up for convenience into separate input and output devices.\
\
In general, units correspond to individual sources of input or output (one tape transport, one A-to-D channel).  Units are the basic medium for both device timing and device I/O.  Except for the console, all I/O devices are simulated as host-resident files.  SCP allows the user to make an explicit association between a host-resident file and a simulated hardware entity.\
\
Both devices and units have state.  Devices operate on 
\i registers
\i0 , which contain information about the state of the device, and indirectly, about the state of the units.  Units operate on 
\i data sets
\i0 , which may be thought of as individual instances of input or output, such as a disk pack or a punched paper tape.  In a typical multi-unit device, all units are the same, and the device performs similar operations on all of them, depending on which one has been selected by the program being simulated.\
\
(Note: SIMH, like MIMIC, restricts registers to devices. Replicated registers, for example, disk drive current state, are handled via register arrays.)\
\
For each structural level, SIMH defines, and the VM must supply, a corresponding data structure.  
\b sim_device
\b0  structures correspond to devices, 
\b sim_reg
\b0  structures to registers, and 
\b sim_unit
\b0  structures to units.  These structures are described in detail in section 4.\
\
The primary functions of a peripheral are:\
\
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 command decoding and execution\
device timing\
data transmission.\
\pard\pardeftab720\ri0
\cf0 \
Command decoding is fairly obvious.  At least one section of the peripheral code module will be devoted to processing directives issued by the CPU.  Typically, the command decoder will be responsible for register and flag manipulation, and for issuing or canceling I/O requests.  The former is easy, but the later requires a thorough understanding of device timing.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls14\ilvl2
\fs24 \cf0 3.2.1	Device Timing\
\pard\pardeftab720\ri0

\fs20 \cf0 \
The principal problem in I/O device simulation is imitating asynchronous operations in a sequential simulation environment.  Fortunately, the timing characteristics of most I/O devices do not vary with external circumstances.  The distinction between devices whose timing is externally generated (e.g., console keyboard) and those whose timing is internally generated (disk, paper tape reader) is crucial.  With an externally timed device, there is no way to know when an in-progress operation will begin or end; with an internally timed device, given the time when an operation starts, the end time can be calculated.\
\
For an internally timed device, the elapsed time between the start and conclusion of an operation is called the wait time.  Some typical internally timed devices and their wait times include:\
\
	PTR (300 char/sec)		3.3 msec\
	PTP (50 char/sec)		20 msec\
	CLK (line frequency)		16.6 msec\
	TTO (30 char/sec)		33 msec\
\
Mass storage devices, such as disks and tapes, do not have a fixed response time, but a start-to-finish time can be calculated based on current versus desired position, state of motion, etc.\
\
For an externally timed device, there is no portable mechanism by which a VM can be notified of an external event (for example, a key stroke).  Accordingly, all current VM\'92s poll for keyboard input, thus converting the externally timed keyboard to a pseudo-internally timed device.  A more general restriction is that SIMH is single-threaded.  Threaded operations must be done by polling using the unit timing mechanism, either with real units or fake units created expressly for polling.\
\
SCP provides the supporting routines for device timing.  SCP maintains a list of devices (called active devices) that are in the process of timing out.  It also provides routines for querying or manipulating this list (called the active queue).  Lastly, it provides a routine for checking for timed-out units and executing a VM-specified action when a time-out occurs.\
\
Device timing is done with the UNIT structure, described in section 4.  To set up a timed operation, the peripheral calculates a waiting period for a unit and places that unit on the active queue.  The CPU counts down the waiting period.  When the waiting period has expired, 
\b sim_process_event
\b0  removes the unit from the active queue and calls a device subroutine.  A device may also cancel an outstanding timed operation and query the state of the queue.  The timing subroutines are:\
\
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 t_stat 
\b sim_activate
\b0  (UNIT *uptr, int32 wait).  This routine places the specified unit on the active queue with the specified waiting period.  A waiting period of 0 is legal; negative waits cause an error.  If the unit is already active, the active queue is not changed, and no error occurs.\
\pard\pardeftab720\ri0
\cf0 \
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 t_stat 
\b sim_cancel
\b0  (UNIT *uptr).  This routine removes the specified unit from the active queue.  If the unit is not on the queue, no error occurs.\
\pard\pardeftab720\ri0
\cf0 \
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 int32 
\b sim_is_active
\b0  (UNIT *uptr).  This routine tests whether a unit is in the active queue.  If it is, the routine returns TRUE(1); if it is not, the routine returns FALSE(0).\
\pard\pardeftab720\ri0
\cf0 \
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 int32 
\b sim_activate_time
\b0  (UNIT *uptr).  This routine returns the time the device has remaining in the queue + 1.  if it is not pending, the routine returns 0.\
\pard\pardeftab720\ri0
\cf0 \
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 double 
\b sim_gtime
\b0  (void).  This routine returns the time elapsed since the last RUN or BOOT command.\
\pard\pardeftab720\ri0
\cf0 \
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 uint32 
\b sim_grtime
\b0  (void).  This routine returns the low-order 32b of the time elapsed since the last RUN or BOOT command.\
\pard\pardeftab720\ri0
\cf0 \
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 int32 
\b sim_qcount
\b0  (void).  This routine returns the number of entries on the clock queue.\
\pard\pardeftab720\ri0
\cf0 \
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 t_stat 
\b sim_process_event
\b0  (void).  This routine removes all timed out units from the active queue and calls the appropriate device subroutine to service the time-out.\
\pard\pardeftab720\ri0
\cf0 \
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 int32 
\b sim_interval
\b0 .  This variable counts down the first outstanding timed event.  If there are no timed events outstanding, SCP counts down a \'93null interval\'94 of 10,000 time units.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls15\ilvl2
\fs24 \cf0 3.2.2	Clock Calibration\
\pard\pardeftab720\ri0

\fs20 \cf0 \
The timing mechanism described in the previous section is approximate.  Devices, such as real-time clocks, which track wall time will be inaccurate.  SCP provides routines to synchronize multiple simulated clocks (to a maximum of 8) to wall time.\
\
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 int32 
\b sim_rtcn_init
\b0  (int32 clock_interval, int32 clk).  This routine initializes the clock calibration mechanism for simulated clock 
\i clk
\i0 .  The argument is returned as the result.\
\pard\pardeftab720\li360\ri0
\cf0 \
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 int32 
\b sim_rtcn_calb
\b0  (int32 tickspersecond, int32 clk).  This routine calibrates simulated clock 
\i clk
\i0 .  The argument is the number of clock ticks expected per second.\
\pard\pardeftab720\ri0
\cf0 \
The VM must call 
\b sim_rtcn_init
\b0  for each simulated clock in two places: in the prolog of 
\b sim_instr
\b0 , before instruction execution starts, and whenever the real-time clock is started.  The simulator calls 
\b sim_rtcn_calb
\b0  to calculate the actual interval delay when the real-time clock is serviced:\
\
	/* clock start */\
\
	if (!sim_is_active (&clk_unit)) sim_activate (&clk_unit, sim_rtcn_init (clk_delay, clkno));\
	etc.\
\
	/* clock service */\
\
	sim_activate (&clk_unit, sim_rtcb_calb (clk_ticks_per_second, clkno);\
\
The real-time clock is usually simulated clock 0; other clocks are used for polling asynchronous multiplexers or intervals timers.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls16\ilvl2
\fs24 \cf0 3.2.3	Idling\
\pard\pardeftab720\ri0

\fs20 \cf0 \
If a VM implements a free-running, calibrated clock of 100Hz or less, then the VM can also implement idling.  Idling is a way of pausing simulation when no real work is happening, without losing clock calibration.  The VM must detect when it is idle; it can then inform the host of this situation by calling 
\b sim_idle
\b0 :\
\
\pard\tx720\pardeftab720\li720\fi-360\ri0
\ls17\ilvl2
\f3 \cf0 \'a5	
\f0 t_bool 
\b sim_idle
\b0  (int32 clk, t_bool one_tick) \'96 attempt to idle the VM until the next scheduled I/O event, using simulated clock 
\i clk
\i0  as the time base, and decrement 
\b sim_interval
\b0  by an appropriate number of cycles.  If a calibrated timer is not available, or the time until the next event is less than 1ms, decrement 
\b sim_interval
\b0  by 1 if 
\i one_tick
\i0  is TRUE; otherwise, leave sim_interval unchanged.\
\pard\pardeftab720\ri0
\cf0 \
\pard\pardeftab720\ri0

\b \cf0 sim_idle
\b0  returns TRUE if the VM actually idled, FALSE if it did not.\
\
Because idling and throttling are mutually exclusive, the VM must inform SCP when idling is turned on or off:\
\
\pard\tx720\pardeftab720\li720\fi-360\ri0
\ls18\ilvl2
\f3 \cf0 \'a5	
\f0 t_stat 
\b sim_set_idle
\b0  (UNIT *uptr, int32 val, char *cptr, void *desc) \'96 informs SCP that idling is enabled.\
\ls18\ilvl2
\f3 \'a5	
\f0 t_stat
\b  sim_clr_idle
\b0  (UNIT *uptr, int32 val, char *cptr, void *desc) \'96 informs SCP that idling is disabled.\
\ls18\ilvl2
\f3 \'a5	
\f0 t_stat 
\b sim_show_idle
\b0  (FILE *st, UNIT *uptr, int32 val, void *desc) \'96 displays whether idling is enabled or disabled, as seen by SCP.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls19\ilvl2
\fs24 \cf0 3.2.4	Data I/O\
\pard\pardeftab720\ri0

\fs20 \cf0 \
For most devices, timing is half the battle (for clocks it is the entire war); the other half is I/O.  Some devices are simulated on real hardware (for example, Ethernet controllers).  Most I/O devices are simulated as files on the host file system in little-endian format.  SCP provides facilities for associating files with units (ATTACH command) and for reading and writing data from and to devices in a endian- and size-independent way.\
\
For most devices, the VM designer does not have to be concerned about the formatting of simulated device files.  I/O occurs in 1, 2, 4, or 8 byte quantities; SCP automatically chooses the correct data size and corrects for byte ordering.  Specific issues:\
\
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 Line printers should write data as 7-bit ASCII, with newlines replacing carriage-return/line-feed sequences.\
\pard\pardeftab720\ri0
\cf0 \
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 Disks should be viewed as linear data sets, from sector 0 of surface 0 of cylinder 0 to the last sector on the disk.  This allows easy transcription of real disks to files usable by the simulator.\
\pard\pardeftab720\ri0
\cf0 \
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 Magtapes, by convention, use a record based format.  Each record consists of a leading 32-bit record length, the record data (padded with a byte of 0 if the record length is odd), and a trailing 32-bit record length.  File marks are recorded as one record length of 0.\
\pard\pardeftab720\ri0
\cf0 \
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 Cards have 12 bits of data per column, but the data is most conveniently viewed as (ASCII) characters.  Column binary can be implemented using two successive characters per card column..\
\pard\pardeftab720\ri0
\cf0 \
Data I/O varies between fixed and variable capacity devices, and between buffered and non-buffered devices.  A fixed capacity device differs from a variable capacity device in that the file attached to the former has a maximum size, while the file attached to the latter may expand indefinitely.  A buffered device differs from a non-buffered device in that the former buffers its data set in host memory, while the latter maintains it as a file.  Most variable capacity devices (such as the paper tape reader and punch) are sequential; all buffered devices are fixed capacity.\
\
\pard\tx1080\pardeftab720\li1080\fi-1080\ri0
\ls20\ilvl3\cf0 3.2.4.1	Reading and Writing Data\
\pard\pardeftab720\ri0
\cf0 \
The ATTACH command creates an association between a host file and an I/O unit.  For non-buffered devices, ATTACH stores the file pointer for the host file in the 
\b fileref
\b0  field of the UNIT structure.  For buffered devices, ATTACH reads the entire host file into a buffer pointed to by the 
\b filebuf 
\b0 field of the UNIT structure.  If unit flag UNIT_MUSTBUF is set, the buffer is allocated dynamically; otherwise, it must be statically allocated.\
\
For non-buffered devices, I/O is done with standard C subroutines plus the SCP routines 
\b sim_fread
\b0  and 
\b sim_fwrite
\b0 .  
\b sim_fread
\b0  and 
\b sim_fwrite
\b0  are identical in calling sequence and function to fread and fwrite, respectively, but will correct for endian dependencies.  For buffered devices, I/O is done by copying data to or from the allocated buffer.  The device code must maintain the number (+1) of the highest address modified in the 
\b hwmark
\b0  field of the UNIT structure.  For both the non-buffered and buffered cases, the device must perform all address calculations and positioning operations.\
\
SIMH provides capabilities to access files >2GB (the int32 position limit).  If a VM is compiled with flags USE_INT64 and USE_ADDR64 defined, then t_addr is defined as t_uint64 rather than uint32.  Routine sim_fseek allows simulated devices to perform random access in large files:\
\
\pard\tx720\pardeftab720\li720\fi-360\ri0
\ls21\ilvl3
\f3 \cf0 \'a5	
\f0 int 
\b sim_fseek
\b0  (FILE *handle, t_addr position, int where)\
\pard\pardeftab720\ri0
\cf0 \
sim_fseek is identical to standard C 
\b fseek
\b0 , with two exceptions: where = SEEK_END is not supported, and the position argument can be 64b wide.\
\
The DETACH command breaks the association between a host file and an I/O unit.  For buffered devices, DETACH writes the allocated buffer back to the host file.\
\
\pard\tx1080\pardeftab720\li1080\fi-1080\ri0
\ls22\ilvl3\cf0 3.2.4.2	Console I/O\
\pard\pardeftab720\ri0
\cf0 \
SCP provides three routines for console I/O.\
\
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 t_stat 
\b sim_poll_char 
\b0 (void).  This routine polls for keyboard input.  If there is a character, it returns SCPE_KFLAG + the character.  If the user typed the interrupt character (^E), it returns SCPE_STOP.  If the console is attached to a Telnet connection, and the connection is lost, the routine returns SCPE_LOST.  If there is no input, it returns SCPE_OK.\
\pard\pardeftab720\ri0
\cf0 \
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 t_stat 
\b sim_putchar
\b0  (int32 char).  This routine types the specified ASCII character to the console.  If the console is attached to a Telnet connection, and the connection is lost, the routine returns SCPE_LOST.\
\pard\pardeftab720\ri0
\cf0 \
\pard\tx720\pardeftab720\li720\fi-360\ri0
\cf0 t_stat 
\b sim_putchar_s
\b0  (int32 char).  This routine outputs the specified ASCII character to the console.  If the console is attached to a Telnet connection, and the connection is lost, the routine returns SCPE_LOST; if the connection is backlogged, the routine returns SCPE_STALL.\
\pard\pardeftab720\ri0
\cf0 \
\pard\tx360\pardeftab720\li360\fi-360\ri0\sb240\sa60
\ls23\ilvl3
\b\fs28 \cf0 4.	Data Structures\
\pard\pardeftab720\ri0

\b0\fs20 \cf0 \
The devices, units, and registers that make up a VM are formally described through a set of data structures which interface the VM to the control portions of SCP.  The devices themselves are pointed to by the device list array 
\b sim_devices[]
\b0 .  Within a device, both units and registers are allocated contiguously as arrays of structures.  In addition, many devices allow the user to set or clear options via a modifications table.\
\
Note that a device must always have at least one unit, even if that unit is not needed for simulation purposes.  A device must always point to a valid register table, but the register table can consist of just the \'93end of table\'94 entry.\
\pard\tx390\pardeftab720\li390\fi-390\ri0\sb240\sa60
\ls24\ilvl1
\i\b\fs24 \cf0 4.1	sim_device Structure\
\pard\pardeftab720\ri0

\i0\b0\fs20 \cf0 \
Devices are defined by the 
\b sim_device
\b0  structure (typedef 
\b DEVICE
\b0 ):\
\
\pard\pardeftab720\li720\ri0
\cf0 struct sim_device \{\
	char		*name;				/* name */\
	struct sim_unit 	*units;				/* units */\
	struct sim_reg	*registers;			/* registers */\
	struct sim_mtab	*modifiers;			/* modifiers */\
	int32		numunits;			/* #units */\
	uint32		aradix;				/* address radix */\
	uint32		awidth;				/* address width */\
	uint32		aincr;				/* addr increment */\
	uint32		dradix;				/* data radix */\
	uint32		dwidth;				/* data width */\
	t_stat		(*examine)();			/* examine routine */\
	t_stat		(*deposit)();			/* deposit routine */\
	t_stat		(*reset)();			/* reset routine */\
	t_stat		(*boot)();			/* boot routine */\
	t_stat		(*attach)();			/* attach routine */\
	t_stat		(*detach)();			/* detach routine */\
	void		*ctxt;
\b 				/
\b0 * context */\
	uint32		flags;				/* flags */\
	uint32		dctrl;				/* debug control flags */\
	struct sim_debtab debflags;
\b 			/
\b0 * debug flag names */\
	t_stat		(*msize)();			/* memory size change */\
	char		*lname;
\b 				/*
\b0  logical name */\
	t_stat		(*help)();
\b 			/*
\b0  help routine */\
	t_stat		(*attach_help)();
\b 			/*
\b0  attach help routine */\
	void		*help_ctxt;
\b 			/
\b0 * help context */\
\pard\pardeftab720\li720\fi720\ri0
\cf0 \};\
\pard\pardeftab720\ri0
\cf0 \
The fields are the following:\
\
\pard\pardeftab720\li720\ri0

\b \cf0 name
\b0 		device name, string of all capital alphanumeric characters.\

\b units
\b0 		pointer to array of 
\b sim_unit
\b0  structures, or NULL if none.\

\b registers
\b0 	pointer to array of 
\b sim_reg
\b0  structures, or NULL if none.\

\b modifiers
\b0 	pointer to array of 
\b sim_mtab
\b0  structures, or NULL if none.\

\b numunits
\b0  	number of units in this device.\

\b aradix
\b0 		radix for input and display of device addresses, 2 to 16 inclusive.\

\b awidth
\b0 		width in bits of a device address, 1 to 64 inclusive.\
\pard\pardeftab720\li2160\fi-1440\ri0

\b \cf0 aincr
\b0 	increment between device addresses, normally 1; however, byte addressed devices with 16-bit words specify 2, with 32-bit words 4.\
\pard\pardeftab720\li720\ri0

\b \cf0 dradix
\b0 		radix for input and display of device data, 2 to 16 inclusive.\

\b dwidth
\b0 		width in bits of device data, 1 to 64 inclusive.\

\b examine
\b0 	address of special device data read routine, or NULL if none is required.\

\b deposit
\b0 		address of special device data write routine, or NULL if none is required.\

\b reset
\b0 		address of device reset routine, or NULL if none is required.\

\b boot
\b0 		address of device bootstrap routine, or NULL if none is required.\

\b attach
\b0 		address of special device attach routine, or NULL if none is required.\

\b detach
\b0 		address of special device detach routine, or NULL if none is required.\

\b ctxt
\b0 		address of VM-specific device context table, or NULL if none is required.\

\b flags
\b0 		device flags.\

\b dctrl		
\b0 debug control flags.\

\b debflags	
\b0 pointer to array of sim_debtab structures, or NULL if none.\

\b msize
\b0 		address of memory size change routine, or NULL if none is required.\

\b lname		
\b0 pointer to logical name string.\

\b help
\b0 		address of help routine, or NULL if none is required.\

\b attach_help
\b0 	address of attach help routine, or NULL if none is required.\

\b help_ctx
\b0 	address of device specific context which might be useful while displaying help \
\pard\pardeftab720\li2160\ri0
\cf0 for the current device, or NULL if none is required.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls25\ilvl2
\fs24 \cf0 4.1.1	Awidth and Aincr\
\pard\pardeftab720\ri0

\f1\fs20 \cf0 \
\pard\pardeftab720\ri0

\f0 \cf0 The 
\b awidth
\b0  field specifies the width of the VM\'92s fundamental computer \'93word\'94.  For example, on the PDP-11, 
\b awidth
\b0  is 16b, even though memory is byte-addressable.  The 
\b aincr
\b0  field specifies how many addressing units comprise the fundamental \'93word\'94.  For example, on the PDP-11, 
\b aincr
\b0  is 2 (2 bytes per word).\
\
If 
\b aincr
\b0  is greater than 1, SCP assumes that data is naturally aligned on addresses that are multiples of 
\b aincr
\b0 .  VM\'92s that support arbitrary byte alignment of data (like the VAX) can follow one of two strategies:\
\
\pard\tx720\pardeftab720\li720\fi-360\ri0
\ls26\ilvl2
\f3 \cf0 \'a5	
\f0 Set 
\b awidth
\b0  = 8 and 
\b aincr
\b0  = 1 and support only byte access in the examine/deposit routines.\
\ls26\ilvl2
\f3 \'a5	
\f0 Set 
\b awidth
\b0  and 
\b aincr
\b0  to the fundamental sizes and support unaligned data access in the examine/deposit routines.\
\pard\pardeftab720\ri0
\cf0 \
In a byte-addressable VM, SAVE and RESTORE will require (memory_size_bytes / 
\b aincr
\b0 ) iterations to save or restore memory.  Thus, it is significantly more efficient to use word-wide rather than byte-wide memory; but requirements for unaligned access can add significantly to the complexity of the examine and deposit routines.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls27\ilvl2
\fs24 \cf0 4.1.2	Device Flags\
\pard\pardeftab720\ri0

\fs20 \cf0 \
The 
\b flags 
\b0 field contains indicators of current device status.  SIMH defines several flags:\
\
\pard\pardeftab720\li720\ri0
\cf0 flag name		meaning if set\
\pard\pardeftab720\ri0
\cf0 \
	DEV_DISABLE		device can be set enabled or disabled\
	DEV_DIS		device is currently disabled\
	DEV_DYNM		device requires call on 
\b msize
\b0  routine to change memory size\
	DEV_DEBUG		device supports SET DEBUG command\
\
The flags field also contains an optional device type specification.  One of these may be specified when initializing the flags field:\
\
	DEV_DISK		device uses sim_disk library attach\
	DEV_TAPE		device uses sim_tape library attach\
	DEV_MUX		device uses sim_tmxr library attach\
	DEV_ETHER		device uses sim_ether library attach\
	DEV_DISPLAY		device uses sim_video library attach\
\
Starting at bit position DEV_V_UF, the remaining flags are device-specific.  Device flags are automatically saved and restored; the device need not supply a register for these bits.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls28\ilvl2
\fs24 \cf0 4.1.3	Context\
\pard\pardeftab720\ri0

\fs20 \cf0 \
The field contains a pointer to a VM-specific device context table, if required.  SIMH never accesses this field.  The context field allows VM-specific code to walk VM-specific data structures from the 
\b sim_devices 
\b0 root pointer.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls29\ilvl2
\fs24 \cf0 4.1.4	Examine and Deposit Routines\
\pard\pardeftab720\ri0

\fs20 \cf0 \
For devices which maintain their data sets as host files, SCP implements the examine and deposit data functions.  However, devices which maintain their data sets as private state (for example, the CPU) must supply special examine and deposit routines.  The calling sequences are:\
\
\pard\pardeftab720\li720\ri0
\cf0 t_stat 
\i examine_routine
\i0  (t_val *eval_array, t_addr addr, UNIT *uptr, int32 switches) \'96 Copy 
\b sim_emax
\b0  consecutive addresses for unit 
\i uptr
\i0 , starting at 
\i addr
\i0 , into 
\i eval_array
\i0 .  The 
\i switch
\i0  variable has bit<n> set if the n\'92th letter was specified as a switch to the examine command.\
\
t_stat 
\i deposit_routine
\i0  (t_val value, t_addr addr, UNIT *uptr, int32 switches) \'96 Store the specified 
\i value
\i0  in the specified 
\i addr
\i0  for unit 
\i uptr
\i0 .  The 
\i switch
\i0  variable is the same as for the examine routine.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls30\ilvl2
\fs24 \cf0 4.1.5	Reset Routine\
\pard\pardeftab720\ri0

\fs20 \cf0 \
The reset routine implements the device reset function for the RESET, RUN, and BOOT commands.  Its calling sequence is:\
\
	t_stat 
\i reset_routine
\i0  (DEVICE *dptr) \'96 Reset the specified device to its initial state.\
\
A typical reset routine clears all device flags and cancels any outstanding timing operations.  Switch \'96p specifies a reset to power-up state.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls31\ilvl2
\fs24 \cf0 4.1.6	Boot Routine\
\pard\pardeftab720\ri0

\fs20 \cf0 \
If a device responds to a BOOT command, the boot routine implements the bootstrapping function.  Its calling sequence is:\
\
\pard\pardeftab720\li720\ri0
\cf0 t_stat 
\i boot_routine
\i0  (int32 unit_num, DEVICE *dptr) \'96 Bootstrap unit  
\i unit_num
\i0  on the device 
\i dptr
\i0 .\
\pard\pardeftab720\ri0
\cf0 \
A typical bootstrap routine copies a bootstrap loader into main memory and sets the PC to the starting address of the loader.  SCP then starts simulation at the specified address.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls32\ilvl2
\fs24 \cf0 4.1.7	Attach and Detach Routines\
\pard\pardeftab720\ri0

\fs20 \cf0 \
Normally, the ATTACH and DETACH commands are handled by SCP.  However, devices which need to pre- or post-process these commands must supply special attach and detach routines.  The calling sequences are:\
\
\pard\pardeftab720\li720\ri0
\cf0 t_stat 
\i attach_routine 
\i0 (UNIT *uptr, char *file) \'96 Attach the specified 
\i file
\i0  to the unit 
\i uptr
\i0 .\
Sim_switches contains the command switch; bit SIM_SW_REST indicates that attach is being called by the RESTORE command rather than the ATTACH command.\
\
t_stat 
\i detach_routine
\i0  (UNIT *uptr) \'96 Detach unit 
\i uptr
\i0 .\
\pard\pardeftab720\ri0
\cf0 \
In practice, these routines usually invoke the standard SCP routines, 
\b attach_unit
\b0  and 
\b detach_unit
\b0 , respectively.  For example, here are special attach and detach routines to update line printer error state:\
\
\pard\pardeftab720\li720\ri0

\f4 \cf0 t_stat lpt_attach (UNIT *uptr, char *cptr) \{\
\pard\pardeftab720\li720\fi720\ri0
\cf0 t_stat r;\
if ((r = attach_unit (uptr, cptr)) != SCPE_OK) return r;\
lpt_error = 0;\
return SCPE_OK;\
\}\
\pard\pardeftab720\li720\ri0
\cf0 \
t_stat lpt_detach (UNIT *uptr) \{\
	lpt_error = 1;\
	return detach_unit (uptr);\
\pard\pardeftab720\li720\fi720\ri0
\cf0 \}\
\pard\pardeftab720\ri0

\f0 \cf0 \
If the VM specifies an ATTACH or DETACH routine, SCP bypasses its normal tests before calling the VM routine.  Thus, a VM DETACH routine cannot be assured that the unit is actually attached and must test the unit flags if required.\
\
SCP executes a DETACH ALL command as part of simulator exit.  Normally, DETACH ALL only calls a unit\'92s detach routine if the unit\'92s UNIT_ATT flag is set.  During simulator exit, the detach routine is also called if the unit is not flagged as attachable (UNIT_ATTABLE is not set).  This allows the detach routine of a non-attachable unit to function as a simulator-specific cleanup routine for the unit, device, or entire simulator.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls33\ilvl2
\fs24 \cf0 4.1.8	Memory Size Change Routine\
\pard\pardeftab720\ri0

\fs20 \cf0 \
Most units instantiate any memory array at the maximum size possible.  This allows apparent memory size to be changed by varying the 
\b capac
\b0  field in the unit structure.  For some devices (like the VAX CPU), instantiating the maximum memory size would impose a significant resource burden if less memory was actually needed.  These devices must provide a routine, the memory size change routine, for RESTORE to use if memory size must be changed:\
\
\pard\pardeftab720\li720\ri0
\cf0 t_stat 
\i change_mem_size
\i0  (UNIT *uptr, int32 val, char *cptr, void *desc) \'96 Change the capacity (memory size) of unit 
\i uptr
\i0  to 
\i val
\i0 .  The 
\i cptr
\i0  and 
\i desc
\i0  arguments are included for compatibility with the SET command\'92s validation routine calling sequence.\
\pard\pardeftab720\ri0
\cf0 \
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls34\ilvl2
\fs24 \cf0 4.1.9	Debug Controls\
\pard\pardeftab720\ri0

\fs20 \cf0 \
Devices can support debug printouts.  Debug printouts are controlled by the SET \{NO\}DEBUG command, which specifies where debug output should be printed; and by the SET <device> \{NO\}DEBUG command, which enables or disables individual debug printouts.\
\
If a device supports debug printouts, device flag DEV_DEBUG must be set.  Field 
\b dctrl
\b0  is used for the debug control flags.  If a device supports only a single debug on/off flag, then the 
\b debflags
\b0  field should be set to NULL.  If a device supports multiple debug on/off flags, then the correspondence between bit positions in 
\b dctrl
\b0  and debug flag names is specified by table  
\b debflags
\b0 .  
\b debflags
\b0  points to a continguous array of 
\b sim_debtab
\b0  structures (typedef 
\b DEBTAB
\b0 ).  Each sim_debtab structure specifies a single debug flag:\
\
	struct sim_debtab \{\
		char		name
\b ;				/
\b0 * flag name */\
		uint32		mask;				/* control bit */\
		\};\
\
The fields are the following:\
\
	name		name of the debug flag.\
	mask		bit mask of the debug flag.\
\
The array is terminated with a NULL entry.\
\
Simulator code can produce debug output by calling sim_debug which is declared:\
\
\pard\pardeftab720\fi720\ri0

\f4 \cf2 void\cf0  _
\f5\b sim_debug
\f4\b0  (uint32 dbits, DEVICE* dptr, \cf2 const\cf0  \cf2 char\cf0 * fmt, ...);\
\pard\pardeftab720\ri0
\cf0 \
\pard\pardeftab720\ri0

\f0 \cf0 The dbits is a flag which matches a mask in a sim_debtab structure, and the the dptr is the DEVICE which has the corresponding dctl field.\
\
Additionally support exists for displaying bit and bitfield values.  Bit field values are defined using the BITFIELD structure and the BIT macros to declare the bits and bitfields.\
\pard\pardeftab720\ri0

\f4 \cf0 \
\pard\pardeftab720\li720\ri0
\cf0 BIT(nm) 			\cf3 - Single Bit definition\
\cf0 BITNC   			\cf3 - Don't care Bit definition\
\cf0 BITF(nm,sz) 		\cf3 - Bit Field definition\
\cf0 BITNCF(sz)			\cf3 - Don't care Bit Field definition\
\cf0 BITFFMT(nm,sz,fmt) 	\cf3 - Bit Field definition with Output format\
\cf0 BITFNAM(nm,sz,names)	\cf3 - Bit Field definition with value->name map\
\cf0 ENDBITS\
\
\pard\pardeftab720\ri0

\f0 \cf0 For example:\
\pard\pardeftab720\li720\ri0

\f4 \cf0 \
\pard\pardeftab720\li720\ri0
\cf2 static\cf0  \cf2 const\cf0  \cf2 char\cf0  *rp_fname[CS1_N_FNC] = \{\
    \cf4 "NOP"\cf0 , \cf4 "UNLD"\cf0 , \cf4 "SEEK"\cf0 , \cf4 "RECAL"\cf0 , \cf4 "DCLR"\cf0 , \cf4 "RLS"\cf0 , \
    \cf4 "OFFS"\cf0 , \cf4 "RETN"\cf0 ,\cf4 "PRESET"\cf0 , \cf4 "PACK"\cf0 , \cf4 "SEARCH"\cf0 , \
    \cf4 "WRCHK"\cf0 , \cf4 "WRITE"\cf0 , \cf4 "WRHDR"\cf0 , \cf4 "READ"\cf0 , \cf4 "RDHDR"\
\pard\pardeftab720\li720\ri0
\cf0     \};\
\
BITFIELD xx_csr_bits[] = \{\
  BIT(GO),                                  \cf3 /* Go */\
\cf0   BITFNAM(FUNC,5,rp_fname),                 \cf3 /* Function Code */\
\cf0   BIT(IE),                                  \cf3 /* Interrupt Enable */\
\cf0   BIT(RDY),                                 \cf3 /* Drive Ready */\
\cf0   BIT(DVA),                                 \cf3 /* Drive Available */\
\cf0   BITNCF(1),                                \cf3 /* 12 Reserved */\
\cf0   BIT(TRE),                                 \cf3 /* Transfer Error */\
\cf0   BIT(SC),                                  \cf3 /* Special Condition */\
\cf0   ENDBITS\
\};\
\pard\pardeftab720\ri0

\f0 \cf0 \
The fields in a register can be displayed (along with transition indicators) by calling sim_debug_bits.\
\
\pard\pardeftab720\li720\ri0

\f4 \cf2 void\cf0  
\f5\b sim_debug_bits
\f4\b0  (uint32 dbits, DEVICE* dptr, BITFIELD* bitdefs, uint32 before, uint32 after, \cf2 int\cf0  terminate);\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls35\ilvl2
\f0\fs24 \cf0 4.1.10	Device Specific Help support\
\pard\pardeftab720\ri0

\fs20 \cf0 \
A device declaration may specify a device type or class in the flags field by providing one of DEV_DISK, DEV_TAPE, DEV_MUX, DEV_ETHER or DEV_DISPLAY values when initializing the flags.  The device type allows the scp HELP command routine to provide some default help information for devices which don\'92t otherwise specify a device specific help routine or a attach_help routine.\
\pard\pardeftab720\ri0

\f1 \cf0 \
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls36\ilvl2
\f0\fs24 \cf0 4.1.11	Help Routine
\f1 \
\pard\pardeftab720\ri0

\f0\fs20 \cf0 \
A device declaration may provide a routine which will display help about that device when a user enters a \'93HELP dev\'94 command.  \
\pard\pardeftab720\ri0

\f4 \cf3 \
\pard\pardeftab720\li720\ri0

\f0 \cf0 t_stat 
\i help
\i0  (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, char *cptr) \'96 Write help information about the device and/or unit usage.  The flag and 
\i cptr
\i0  arguments are included for compatibility with the HELP command\'92s validation routine calling sequence.\
\pard\pardeftab720\ri0
\cf0 \
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls37\ilvl2
\fs24 \cf0 4.1.12	Attach Help Routine\
\pard\pardeftab720\ri0

\fs20 \cf0 \
A device declaration may provide a routine which will display help about hORE to use if memory size must be changed:\
\
\pard\pardeftab720\li720\ri0
\cf0 t_stat attach_
\i help
\i0  (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, char *cptr) \'96 Write help information about the device and/or unit attach usage.  The flag and 
\i cptr
\i0  arguments are included for compatibility with the HELP command\'92s validation routine calling sequence.\
\pard\pardeftab720\ri0
\cf0 \
\
\pard\tx390\pardeftab720\li390\fi-390\ri0\sb240\sa60
\ls38\ilvl1
\i\b\fs24 \cf0 4.2	sim_unit Structure\
\pard\pardeftab720\ri0

\i0\fs20 \cf0 \
\pard\pardeftab720\ri0

\b0 \cf0 Units are allocated as contiguous array.  Each unit is defined with a 
\b sim_unit
\b0  structure (typedef 
\b UNIT
\b0 ):\
\
\pard\pardeftab720\li720\ri0
\cf0 struct sim_unit \{\
	struct sim_unit	*next;				/* next active */\
	t_stat		(*action)();			/* action routine */\
	char		*filename;			/* open file name */\
	FILE		*fileref;				/* file reference */\
	void		*filebuf;				/* memory buffer */\
	uint32		hwmark;			/* high water mark */\
	int32		time;				/* time out */\
	uint32		flags;				/* flags */\
	t_addr		capac;				/* capacity */\
	t_addr		pos;				/* file position */\
	int32		buf;				/* buffer */\
	int32		wait;				/* wait */\
	int32		u3;				/* device specific */\
	int32		u4;				/* device specific */\
	int32		u5;				/* device specific */\
	int32		u6;				/* device specific */\
\pard\pardeftab720\li720\fi720\ri0
\cf0 \};\
\pard\pardeftab720\ri0
\cf0 \
The fields are the following:\
\
\pard\pardeftab720\li720\ri0

\b \cf0 next
\b0 		pointer to next unit in active queue, NULL if none.\

\b action
\b0 		address of unit time-out service routine.\

\b filename
\b0 	pointer to name of attached file, NULL if none.\

\b fileref
\b0 		pointer to FILE structure of attached file, NULL if none.\

\b hwmark
\b0 	buffered devices only; highest modified address, + 1.\

\b time
\b0 		increment until time-out beyond previous unit in active queue.\

\b flags
\b0 		unit flags.\

\b capac
\b0 		unit capacity, 0 if variable.\

\b pos
\b0 		sequential devices only; next device address to be read or written.\

\b buf
\b0 		by convention, the unit buffer, but can be used for other purposes.\

\b wait
\b0 		by convention, the unit wait time, but can be used for other purposes.\

\b u3
\b0 		user-defined.\

\b u4
\b0 		user-defined.\

\b u5		
\b0 user-defined.\

\b u6		
\b0 user-defined.\
\pard\pardeftab720\ri0

\b \cf0 \
buf, wait, u3, u4, u5, u6, 
\b0 and parts of 
\b flags
\b0  are all saved and restored by the SAVE and RESTORE commands and thus can be used for unit state which must be preserved.\
\
Macro 
\b UDATA
\b0  is available to fill in the common fields of a UNIT.  It is invoked by\
\
	UDATA		(action_routine, flags, capacity)\
\
Fields after 
\b buf
\b0  can be filled in manually, e.g,\
\
\pard\pardeftab720\ri0

\f4 \cf0 	UNIT lpt_unit = \
\pard\pardeftab720\li720\fi720\ri0
\cf0 \{ UDATA (&lpt_svc, UNIT_SEQ+UNIT_ATTABLE, 0), 500 \};\
\pard\pardeftab720\ri0

\f0 \cf0 \
defines the line printer as a sequential unit with a wait time of 500.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls39\ilvl2
\fs24 \cf0 4.2.1	Unit Flags\
\pard\pardeftab720\ri0

\fs20 \cf0 \
The 
\b flags 
\b0 field contains indicators of current unit status.  SIMH defines 12 flags:\
\
\pard\pardeftab720\li720\ri0
\cf0 flag name		meaning if set\
\
UNIT_ATTABLE	the unit responds to ATTACH and DETACH.\
UNIT_RO		the unit is currently read only.\
UNIX_FIX		the unit is fixed capacity.\
UNIT_SEQ		the unit is sequential.\
UNIT_ATT		the unit is currently attached to a file.\
UNIT_BINK		the unit measures \'93K\'94 as 1024, rather than 1000.\
UNIT_BUFABLE	the unit buffers its data set in memory.\
UNIT_MUSTBUF	the unit allocates its data buffer dynamically.\
UNIT_BUF		the unit is currently buffering its data set in memory.\
UNIT_ROABLE		the unit can be ATTACHed read only.\
UNIT_DISABLE		the unit responds to ENABLE and DISABLE.\
UNIT_DIS		the unit is currently disabled.\
UNIT_RAW		the unit is attached in RAW mode.\
\pard\pardeftab720\ri0
\cf0 \
Starting at bit position UNIT_V_UF, the remaining flags are unit-specific.  Unit-specific flags are set and cleared with the SET and CLEAR commands, which reference the MTAB array (see below).  Unit-specific flags and UNIT_DIS are automatically saved and restored; the device need not supply a register for these bits.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls40\ilvl2
\fs24 \cf0 4.2.2	Service Routine\
\pard\pardeftab720\ri0

\fs20 \cf0 \
This routine is called by 
\b sim_process_event
\b0  when a unit times out.  Its calling sequence is:\
\
\pard\pardeftab720\fi720\ri0
\cf0 t_stat 
\i service_routine
\i0  (UNIT *uptr)\
\pard\pardeftab720\ri0
\cf0 \
The status returned by the service routine is passed by 
\b sim_process_event
\b0  back to the CPU.\
\pard\tx390\pardeftab720\li390\fi-390\ri0\sb240\sa60
\ls41\ilvl1
\i\b\fs24 \cf0 4.3	sim_reg Structure\
\pard\pardeftab720\ri0

\i0\fs20 \cf0 \
\pard\pardeftab720\ri0

\b0 \cf0 Registers are allocated as contiguous array, with a NULL register at the end.  Each register is defined with a 
\b sim_reg
\b0  structure (typedef 
\b REG
\b0 ):\
\
\pard\pardeftab720\li720\ri0
\cf0 struct reg \{\
	char		*name;				/* name */\
	void		*loc;				/* location */\
	uint32		radix;				/* radix */\
	uint32		width;				/* width */\
	uint32		offset;				/* starting bit */\
	uint32		depth;				/* save depth */\
	char		*desc;				/* description */\
	struct bitfield	*fields;				/* bit fields */\
	uint32		flags;				/* flags */\
	uint32		qptr;				/* current queue pointer */\
\pard\pardeftab720\li720\fi720\ri0
\cf0 \};\
\pard\pardeftab720\ri0
\cf0 \
The fields are the following:\
\
\pard\pardeftab720\li720\ri0

\b \cf0 name
\b0 		device name, string of all capital alphanumeric characters.\

\b loc
\b0 		pointer to location of the register value.\

\b radix
\b0 		radix for input and display of data, 2 to 16 inclusive.\

\b width
\b0 		width in bits of data, 1 to 32 inclusive.\

\b offset	
\b0 	bit offset (from right end of data).\

\b depth	
\b0 	size of data array (normally 1).\

\b desc
\b0 		register description.\

\b fields
\b0 		bit fields and formatting information.\

\b flags
\b0 		flags and formatting information.\

\b qptr
\b0 		for a circular queue, the entry number for the first entry\
\pard\pardeftab720\ri0
\cf0 \
The 
\b depth
\b0  field is used with \'93arrayed registers\'94.  Arrayed registers are used to represent structures with multiple data values, such as the locations in a transfer buffer; or structures which are replicated in every unit, such as a drive status register.  The 
\b qptr
\b0  field is used with \'93queued registers\'94.  Queued registers are arrays that are organized as circular queues, such as the PC change queue.  The 
\b desc
\b0  field (if present) is displayed by the HELP dev REGISTER command to enumerate the device registers and describe them.  The 
\b fields
\b0  field (if present) is used to display details of a register\'92s content according to the respective field descriptions.\
\
A register that is 32b or less keeps its data in a 32b scalar variable (signed or unsigned).  A register that is 33b or more keeps its data in a 64b scalar variable (signed or unsigned).  There are several exceptions to this rule:\
\
\pard\tx720\pardeftab720\li720\fi-360\ri0
\ls42\ilvl1
\f3 \cf0 \'a5	
\f0 An arrayed register keeps its data in a C-array whose SIMH data type is as large as (or if necessary, larger than), the width of a register element.  For example, an array of 6b registers would keep its data in a uint8 (or int8) array; an array of 16b registers would keep its data in a uint16 (or int16) array; an array of 24b registers would keep its data in a uint32 (or int32) array.\
\ls42\ilvl1
\f3 \'a5	
\f0 A register flagged with REG_FIT obeys the sizing rules of an arrayed register, rather than a normal scalar register.  This is useful for aliasing registers into memory or into structures.\
\pard\pardeftab720\ri0
\cf0 \
Macros 
\b ORDATA
\b0 , 
\b DRDATA
\b0 , and 
\b HRDATA
\b0  define right-justified octal, decimal, and hexidecimal registers, respectively.  They are invoked by:\
\
	xRDATA	(name, location, width)\
\
Macro 
\b FLDATA
\b0  defines a one-bit binary flag at an arbitrary offset in a 32-bit word.  It is invoked by:\
\
	FLDATA	(name, location, bit_position)\
\
Macro 
\b GRDATA
\b0  defines a register with arbitrary location and radix.  It is invoked by:\
\
	GRDATA	(name, location, radix, width, bit_position)\
\
Macro 
\b BRDATA
\b0  defines an arrayed register whose data is kept in a standard C array.  It is invoked by:\
\
	BRDATA	(name, location, radix, width, depth)\
\
For all of these macros, the 
\b flag
\b0  field can be filled in manually, e.g.,\
\
\pard\pardeftab720\ri0

\f4 \cf0 	REG lpt_reg = \{\
		\{ DRDATA	(POS, lpt_unit.pos, 31), PV_LFT \}, \'85 \}\
\pard\pardeftab720\ri0

\f0 \cf0 \
Finally, macro 
\b URDATA
\b0  defines an arrayed register whose data is part of the 
\b UNIT
\b0  structure.  This macro must be used with great care.  If the fields are set up wrong, or the data is actually kept somewhere else, storing through this register declaration can trample over memory.  The macro is invoked by:\
\
	URDATA	(name, location, radix, width, offset, depth, flags)\
\
The location should be an offset in the 
\b UNIT 
\b0 structure for unit 0.  The width should be 32 for an int32 or uint32 field, and T_ADDR_W for a t_addr filed.  The flags can be any of the normal register flags; REG_UNIT will be OR\'92d in automatically.  For example, the following declares an arrayed register of all the 
\b UNIT 
\b0 position fields in a device with 4 units:\
\
\pard\pardeftab720\ri0

\f4 \cf0 	\{ URDATA	(POS, dev_unit[0].pos, 8, T_ADDR_W, 0, 4, 0) \}\
\
\pard\pardeftab720\ri0

\f0 \cf0 Each of the ORDATA, DRDATA, BRDATA, FLDATA, GRDATA, BRDATA and URDATA macros has corresponding \'91D\'92 and \'91DF\'92 macros (ORDATAD, DRDATAD, BRDATAD, FLDATAD, GRDATAD, BRDATAD and URDATAD and ORDATADF, DRDATADF, BRDATADF, FLDATADF, GRDATADF, BRDATADF and URDATADF) which can be used to provide initialization values to the 
\b desc 
\b0 and
\b  fields
\b0  the reg structure.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls43\ilvl2
\fs24 \cf0 4.3.1	Register Flags\
\pard\pardeftab720\ri0

\fs20 \cf0 \
The 
\b flags 
\b0 field contains indicators that control register examination and deposit.\
\
\pard\pardeftab720\li720\ri0
\cf0 flag name		meaning if specified\
\
PV_RZRO		print register right justified with leading zeroes.\
PV_RSPC		print register right justified with leading spaces.\
PV_RCOMMA		print register right justified space fill comma\'92s every 3.\
PV_LEFT		print register left justified.\
REG_RO		register is read only.\
REG_HIDDEN		register is hidden (will not appear in EXAMINE STATE).\
REG_HRO		register is read only and hidden.\
REG_NZ		new register values must be non-zero.\
REG_UNIT		register resides in the 
\b UNIT
\b0  structure.\
REG_CIRC		register is a circular queue.\
REG_VMIO		register is displayed and parsed using VM data routines.\
REG_VMAD		register is displayed and parsed using VM address routines.\
REG_FIT		register container uses arrayed rather than scalar size rules.\
\pard\tx390\pardeftab720\li390\fi-390\ri0\sb240\sa60
\ls44\ilvl1
\i\b\fs24 \cf0 4.4	sim_bitfield Structure\
\pard\pardeftab720\ri0

\f1\i0\b0\fs20 \cf0 \
\pard\pardeftab720\ri0

\f0 \cf0 Bitfields are allocated as contiguous array, with a NULL bitfield at the end.  Each bitfield is defined with a 
\b sim_bitfield
\b0  structure (typedef 
\b BITFIELD
\b0 ):\
\pard\pardeftab720\li720\ri0
\cf0 \
struct sim_bitfield \{\
	char		*name;				/* field name */\
	uint32		offset;				/* starting bit */\
	uint32		width;				/* width */\
	char		**valuenames;			/* map of values to strings */\
	char		*format;				/* value format string */\
\pard\pardeftab720\li720\fi720\ri0
\cf0 \};\
\pard\pardeftab720\ri0
\cf0 \
The fields are the following:\
\
\pard\pardeftab720\li720\ri0

\b \cf0 name
\b0 		field name, string of alphanumeric characters.\

\b offset
\b0 		starting bit (normally populated automatically).\

\b width
\b0 		width in bits of data, 1 to 32 inclusive.\

\b valuenames
\b0 	pointer to a string array which maps fields values\

\b format	
\b0 	value format string\
\pard\pardeftab720\ri0
\cf0 \
Macros 
\b BIT
\b0  and 
\b BITF
\b0  define single bit and multi-bit fields, respectively.  They are invoked by:\
\
	BIT		(name)\
	BITF		(name, width)\
\
Macros 
\b BITNC
\b0  and 
\b BITNCF
\b0  define single bit and multi-bit don\'92t care fields, respectively.  They are invoked by:\
\
	BITNC		\
	BITFNCF	(width)\
\
Macro 
\b BITFFMT
\b0  defines a bit fields with an output format specifier.  It is invoked by:\
\
	BITFFMT	(name, width, fmt)\
\
Macro 
\b BITFNAM
\b0  defines a bit fields with a value to name string map.  It is invoked by:\
\
	BITFFMT	(name, width, maparray)\
\
\pard\pardeftab720\ri0

\f1 \cf0 \
\pard\tx390\pardeftab720\li390\fi-390\ri0\sb240\sa60
\ls45\ilvl1
\f0\i\b\fs24 \cf0 4.5	sim_mtab Structure\
\pard\pardeftab720\ri0

\f1\i0\b0\fs20 \cf0 \
\pard\pardeftab720\ri0

\f0\b \cf0 \
\pard\pardeftab720\ri0

\b0 \cf0 Device-specific SHOW and SET commands are processed using the modifications array, which is allocated as contiguous array, with a NULL at the end.  Each possible modification is defined with a 
\b sim_mtab
\b0  structure (synonym 
\b MTAB
\b0 ), which has the following fields:\
\
\pard\pardeftab720\li720\ri0
\cf0 struct sim_mtab \{\
	uint32		mask;				/* mask */\
	uint32		match;				/* match */\
	char		*pstring;			/* print string */\
	char		*mstring;			/* match string */\
	t_stat		(*valid)();			/* validation routine */\
	t_stat		(*disp)();			/* display routine */\
	void		*desc
\b ;				/
\b0 * location descriptor */\
	char		*help
\b ;				/
\b0 * help string */\
\pard\pardeftab720\li720\fi720\ri0
\cf0 \};\
\pard\pardeftab720\ri0
\cf0 \
MTAB supports two different structure interpretations: regular and extended.  A regular MTAB entry modifies flags in the UNIT flags word; the descriptor entry is not used.  The fields are the following:\
\
\pard\pardeftab720\li720\ri0

\b \cf0 mask
\b0 		bit mask for testing the unit.
\b flags
\b0  field\
\pard\pardeftab720\li2160\fi-1440\ri0

\b \cf0 match
\b0 	value to be stored (SET) or compared (SHOW)\

\b pstring
\b0 	pointer to character string printed on a match (SHOW), or NULL\

\b mstring
\b0 	pointer to character string to be matched (SET), or NULL\

\b valid
\b0 	address of validation routine (SET), or NULL\

\b disp	
\b0 address of display routine (SHOW), or NULL\
\pard\pardeftab720\ri0

\b \cf0 \
\pard\pardeftab720\ri0

\b0 \cf0 For SET, a regular MTAB entry is interpreted as follows:\
\
\pard\tx1080\pardeftab720\li1080\fi-360\ri0
\cf0 Test to see if the 
\b mstring
\b0  entry exists.\
Test to see if the SET parameter matches the 
\b mstring
\b0 .\
Call the validation routine, if any.\
Apply the 
\b mask
\b0  value to the UNIT flags word and then or in the 
\b match
\b0  value. \
\pard\pardeftab720\ri0
\cf0 \
For SHOW, a regular MTAB entry is interpreted as follows:\
\
\pard\tx1080\pardeftab720\li1080\fi-360\ri0
\cf0 Test to see if the 
\b pstring
\b0  entry exists.\
Test to see if the UNIT flags word, masked with the 
\b mask
\b0  value, equals the 
\b match
\b0  value.\
If a display routine exists, call it, otherwise\
Print the 
\b pstring
\b0 .\
\pard\pardeftab720\ri0
\cf0 \
Extended MTAB entries have a different interpretation:\
\
\pard\pardeftab720\li720\ri0

\b \cf0 mask
\b0 		entry flags\

\b 		
\b0 MTAB_XTD	extended entry\
		MTAB_VDV	valid for devices\
		MTAB_VUN	valid for units\
		MTAB_VALR	requires a value\
		MTAB_VALO	optionally requires a value\
		MTAB_NMO	valid only in named SHOW\
		MTAB_NC	do not convert option value to upper case\
		MTAB_SHP	SHOW parameter takes optional value\
\pard\pardeftab720\li2160\fi-1440\ri0

\b \cf0 match
\b0 	value to be stored (SET)\

\b pstring
\b0 	pointer to character string printed on a match (SHOW), or NULL\

\b mstring
\b0 	pointer to character string to be matched (SET), or NULL\

\b valid
\b0 	address of validation routine (SET), or NULL\

\b disp	
\b0 address of display routine (SHOW), or NULL\

\b desc	
\b0 pointer to a REG structure (MTAB_VAL set) or\

\b 	
\b0 a validation-specific structure (MTAB_VAL clear)\
\pard\pardeftab720\ri0
\cf0 \
For SET, an extended MTAB entry is interpreted as follows:\
\
\pard\tx1080\pardeftab720\li1080\fi-360\ri0
\cf0 Test to see if the 
\b mstring
\b0  entry exists.\
Test to see if the SET parameter matches the 
\b mstring
\b0 .\
Test to see if the entry is valid for the type of SET being done (SET device or SET unit).\
If a validation routine exists, call it and return its status.  The validation routine is responsible for storing the result. \
If 
\b desc
\b0  is NULL, exit.\
If MTAB_VAL is set, parse the SET option for \'93option=n\'94, and store the value n in the register described by 
\b desc
\b0 .\
Otherwise, store the 
\b match
\b0  value in the int32 pointed to by 
\b desc
\b0 .\
\pard\pardeftab720\ri0
\cf0 \
For SHOW, an extended MTAB entry is interpreted as follows:\
\
\pard\tx1080\pardeftab720\li1080\fi-360\ri0
\cf0 Test to see if the 
\b pstring
\b0  entry exists.\
Test to see if the entry is valid for the type of SHOW being done (device or unit).\
If a display routine exists, call it, otherwise,\
If MTAB_VAL is set, print \'93pstring=n\'94, where the value, radix, and width are taken from the register described by 
\b desc
\b0 , otherwise,\
Print the 
\b pstring
\b0 .\
\pard\pardeftab720\ri0
\cf0 \
SHOW [dev|unit] <modifier>\{=<value>\} is a special case.  Only two kinds of modifiers can be displayed individually: an extended MTAB entry that takes a value; and any MTAB entry with both a display routine and a 
\b pstring
\b0 .  Recall that if a display routine exists, SHOW does not use the 
\b pstring
\b0  entry.  For displaying a named modifier, 
\b pstring
\b0  is used as the string match.  This allows implementation of complex display routines that are only invoked by name, e.g.,\
\
\pard\pardeftab720\ri0

\f4 \cf0 	MTAB cpu_tab[] = \{\
		\{ mask, value, \'93normal\'94, \'93NORMAL\'94, NULL, NULL, NULL \},\
		\{ MTAB_XTD|MTAB_VDV|MTAB_NMO, 0, \'93SPECIAL\'94,\
\pard\pardeftab720\li1440\fi720\ri0
\cf0 NULL, NULL, NULL, &spec_disp \},\
\pard\pardeftab720\ri0
\cf0 		\{ 0 \}\
\pard\pardeftab720\li720\fi720\ri0
\cf0 \};\
\pard\pardeftab720\ri0

\f0 \cf0 \
A SHOW CPU command will display only the modifier named NORMAL; but SHOW CPU SPECIAL will invoke the special display routine.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls46\ilvl2
\fs24 \cf0 4.5.1	Validation Routine\
\pard\pardeftab720\ri0

\fs20 \cf0 \
The validation routine can be used to validate input during SET processing.  It can make other state changes required by the modification or initiate additional dialogs needed by the modifier.  Its calling sequence is:\
\
\pard\pardeftab720\li720\ri0
\cf0 t_stat 
\i validation_routine
\i0  (UNIT *uptr, int32 value, char *cptr, void *desc) \'96 test that 
\i uptr
\i0 .
\b flags
\b0  can be set to 
\i value
\i0 .  
\i cptr
\i0  points to the value portion of the parameter string (any characters after the = sign); if 
\i cptr
\i0  is NULL, no value was given.  
\i desc
\i0  points to the 
\b REG
\b0  or int32 used to store the parameter.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls47\ilvl2
\fs24 \cf0 4.5.2	Display Routine\
\pard\pardeftab720\ri0

\fs20 \cf0 \
The display routine is called during SHOW processing to display device- or unit-specific state.  Its calling sequence is:\
\
\pard\pardeftab720\li720\ri0
\cf0 t_stat 
\i display_routine
\i0  (FILE *st, UNIT *uptr, int value, void *desc) \'96 output device- or unit-specific state for 
\i uptr
\i0  to stream 
\i st
\i0 .  If the modifier is regular MTAB entry, or an extended entry without MTAB_SHP set, 
\i desc
\i0  points to the structure in the MTAB entry.  If the modifier is an extended MTAB entry with MTAB_SHP set, 
\i desc
\i0  points to the optional value string or is NULL if no value was supplied.  
\i value
\i0  is the value field of the matched MTAB entry.\
\pard\pardeftab720\ri0
\cf0 \
When the display routine is called for a regular MTAB entry, SHOW has output the 
\b pstring
\b0  argument but has not appended a newline.  When it is called for an extended MTAB entry, SHOW hasn\'92t output anything.  SHOW will append a newline after the display routine returns, except for entries with the MTAB_NMO flag set.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls48\ilvl2
\fs24 \cf0 4.5.3	Help Flags\
\pard\pardeftab720\ri0

\f1\fs20 \cf0 \
The flags MTAB_VALR and MTAB_VALO are used to construct command syntax examples when displaying help for SET and SHOW commands.  These flags do not otherwise influence the actions taken during processing of SET or SHOW commands.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls49\ilvl2
\f0\fs24 \cf0 4.5.4	Example arguments in the 
\b mstring
\f1\b0 \
\pard\pardeftab720\ri0

\fs20 \cf0 \
The value of the 
\b mstring
\b0  field may contain examples of valid additional parameters which may be specified as values.  For example:\
\
\pard\pardeftab720\ri0

\f4 \cf0 	MTAB cr_mod[] = \{\
		\{ mask, value, \'93normal\'94, \'93NORMAL\'94, NULL, NULL, NULL \},\
		\{ MTAB_XTD|MTAB_VDV, 0, \'93TRANSLATION\'94,\
\pard\pardeftab720\li1440\fi720\ri0
\cf0 \'93TRANSLATION=\{DEFAULT|026|026FTN|029|EBCDIC\}\'94,\
NULL, &cr_set_trans, &cr_show_trans \},\
\pard\pardeftab720\ri0
\cf0 		\{ 0 \}\
\pard\pardeftab720\li720\fi720\ri0
\cf0 \};\
\pard\pardeftab720\ri0

\f1 \cf0 \
This entry has an 
\b mstring
\b0  value of  \'93
\f4 TRANSLATION=\{DEFAULT|026|026FTN|029|EBCDIC\}
\f1 \'94.  When comparisons are made against this string, everything starting at the equal sign and beyond is irrelevant to the match activity since the input being compared has already been parsed with a delimiter of \'91=\'92.  The remaining parts of the 
\b mstring
\b0  value are ignored, but are available when constructing HELP dev SET output.\
\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls50\ilvl2
\f0\fs24 \cf0 4.5.5	Help field\
\pard\pardeftab720\ri0

\f1\fs20 \cf0 \
The MTAB entry\'92s help field is used when constructing HELP dev SHOW or HELP dev SHOW output.  It serves to describe the purpose or effect of the particular SET dev or SHOW dev command.  The help field is ignored when constructing HELP dev SET output for MTAB entries which have an equal sign in the mstring field. \
\pard\pardeftab720\ri0

\f0 \cf0 \
\pard\tx390\pardeftab720\li390\fi-390\ri0\sb240\sa60
\ls51\ilvl1
\i\b\fs24 \cf0 4.6	Other Data Structures\
\pard\pardeftab720\ri0

\i0\b0\fs20 \cf0 \
char 
\b sim_name[]
\b0  is a character array containing the VM name.\
\
int32 
\b sim_emax
\b0  contains the maximum number of words needed to hold the largest instruction or data item in the VM.  Examine and deposit will process up to 
\b sim_emax
\b0  words.\
\
DEVICE *
\b sim_devices[]
\b0  is an array of pointers to all the devices in the VM.  It is terminated by a NULL.  By convention, the CPU is always the first device in the array.\
\
REG *
\b sim_PC
\b0  points to the 
\b reg
\b0  structure for the program counter.  By convention, the PC is always the first register in the CPU\'92s register array.\
\
char *
\b sim_stop_messages[]
\b0  is an array of pointers to character strings, corresponding to error status returns greater than zero.  If 
\b sim_instr
\b0  returns status code n > 0 but less than SCPE_BASE, then 
\b sim_stop_message[n]
\b0  is printed by SCP.\
\
\pard\tx360\pardeftab720\li360\fi-360\ri0\sb240\sa60
\ls52\ilvl1
\b\fs28 \cf0 5.	VM Provided Routines\
\pard\tx390\pardeftab720\li390\fi-390\ri0\sb240\sa60
\ls52\ilvl1
\i\fs24 \cf0 5.1	Instruction Execution\
\pard\pardeftab720\ri0

\i0\b0\fs20 \cf0 \
Instruction execution is performed by routine 
\b sim_instr
\b0 .  Its calling sequence is:\
\
\pard\pardeftab720\fi720\ri0
\cf0 t_stat 
\b sim_instr
\b0  (void) \'96 execute from current PC until error or halt.\
\pard\tx390\pardeftab720\li390\fi-390\ri0\sb240\sa60
\ls53\ilvl1
\i\b\fs24 \cf0 5.2	Binary Load and Dump\
\pard\pardeftab720\ri0

\i0\b0\fs20 \cf0 \
If the VM responds to the LOAD (or DUMP) command, the load routine (dump routine) is implemented by routine 
\b sim_load
\b0 .  Its calling sequence is:\
\
\pard\pardeftab720\li720\ri0
\cf0 t_stat 
\b sim_load
\b0  (FILE *fptr, char *buf, char *fnam, t_bool flag) - If 
\i flag
\i0  = 0, load data from binary file 
\i fptr
\i0 .  If 
\i flag
\i0  = 1, dump data to binary file 
\i fptr
\i0 .  For either command, 
\i buf
\i0  contains any VM-specific arguments, and 
\i fnam
\i0  contains the file name.  \
\pard\pardeftab720\ri0
\cf0 \
If LOAD or DUMP is not implemented, 
\b sim_load
\b0  should simply return SCPE_ARG.  The LOAD and DUMP commands open and close the specified file for 
\b sim_load
\b0 .\
\pard\tx390\pardeftab720\li390\fi-390\ri0\sb240\sa60
\ls54\ilvl1
\i\b\fs24 \cf0 5.3	Symbolic Examination and Deposit\
\pard\pardeftab720\ri0

\i0\b0\fs20 \cf0 \
If the VM provides symbolic examination and deposit of data, it must provide two routines, 
\b fprint_sym
\b0  for output and 
\b parse_sym
\b0  for input.  Their calling sequences are:\
\
\pard\pardeftab720\li720\ri0
\cf0 t_stat 
\b fprint_sym
\b0  (FILE *ofile, t_addr addr, t_value *val, UNIT *uptr, int32 switch) \'96 Based on the 
\i switch
\i0  variable, symbolically output to stream 
\i ofile
\i0  the data in array 
\i val
\i0  at the specified 
\i addr
\i0  in unit 
\i uptr
\i0 .\
\
t_stat 
\b parse_sym
\b0  (char *cptr, t_addr addr, UNIT *uptr, t_value *val, int32 switch) \'96 Based on the 
\i switch
\i0  variable, parse character string 
\i cptr
\i0  for a symbolic value 
\i val
\i0  at the specified 
\i addr
\i0  in unit 
\i uptr
\i0 .\
\pard\pardeftab720\ri0
\cf0 \
If symbolic processing is not implemented, or the output value or input string cannot be parsed, these routines should return SCPE_ARG.  If the processing was successful and consumed more than a single word, then these routines should return extra number of addressing units consumed as a 
\b negative
\b0  number.  If the processing was successful and consumed a single addressing unit, then these routines should return SCPE_OK.  For example, PDP-11 
\b parse_sym
\b0  would respond as follows to various inputs:\
\
	input				return value\
\
	XYZGH				SCPE_ARG\
	MOV R0,R1			-1\
	MOV #4,R5			-3\
	MOV 1234,5670		-5\
\
There is an implicit relationship between the 
\b addr
\b0  and 
\b val
\b0  arguments and the device\'92s 
\b aincr
\b0  fields.  Each entry in 
\b val
\b0  is assumed to represent 
\b aincr
\b0  addressing units, starting at 
\b addr
\b0 :\
\

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrt\brdrs\brdrw10\brdrcf5 \trbrdrl\brdrs\brdrw10\brdrcf5 \trbrdrr\brdrs\brdrw10\brdrcf5 
\clvertalt \clshdrawnil \clwWidth2970\clftsWidth3 \clbrdrt\brdrs\brdrw10\brdrcf5 \clbrdrl\brdrs\brdrw10\brdrcf5 \clbrdrb\brdrs\brdrw10\brdrcf5 \clbrdrr\brdrs\brdrw10\brdrcf5 \clpadl100 \clpadr100 \gaph\cellx4320
\clvertalt \clshdrawnil \clwWidth2970\clftsWidth3 \clbrdrt\brdrs\brdrw10\brdrcf5 \clbrdrl\brdrs\brdrw10\brdrcf5 \clbrdrb\brdrs\brdrw10\brdrcf5 \clbrdrr\brdrs\brdrw10\brdrcf5 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\ri0
\cf0 val[0]\cell 
\pard\intbl\itap1\pardeftab720\ri0
\cf0 addr + 0\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrs\brdrw10\brdrcf5 \trbrdrr\brdrs\brdrw10\brdrcf5 
\clvertalt \clshdrawnil \clwWidth2970\clftsWidth3 \clbrdrt\brdrs\brdrw10\brdrcf5 \clbrdrl\brdrs\brdrw10\brdrcf5 \clbrdrb\brdrs\brdrw10\brdrcf5 \clbrdrr\brdrs\brdrw10\brdrcf5 \clpadl100 \clpadr100 \gaph\cellx4320
\clvertalt \clshdrawnil \clwWidth2970\clftsWidth3 \clbrdrt\brdrs\brdrw10\brdrcf5 \clbrdrl\brdrs\brdrw10\brdrcf5 \clbrdrb\brdrs\brdrw10\brdrcf5 \clbrdrr\brdrs\brdrw10\brdrcf5 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\ri0
\cf0 val[1]\cell 
\pard\intbl\itap1\pardeftab720\ri0
\cf0 addr + aincr\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrs\brdrw10\brdrcf5 \trbrdrr\brdrs\brdrw10\brdrcf5 
\clvertalt \clshdrawnil \clwWidth2970\clftsWidth3 \clbrdrt\brdrs\brdrw10\brdrcf5 \clbrdrl\brdrs\brdrw10\brdrcf5 \clbrdrb\brdrs\brdrw10\brdrcf5 \clbrdrr\brdrs\brdrw10\brdrcf5 \clpadl100 \clpadr100 \gaph\cellx4320
\clvertalt \clshdrawnil \clwWidth2970\clftsWidth3 \clbrdrt\brdrs\brdrw10\brdrcf5 \clbrdrl\brdrs\brdrw10\brdrcf5 \clbrdrb\brdrs\brdrw10\brdrcf5 \clbrdrr\brdrs\brdrw10\brdrcf5 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\ri0
\cf0 val[2]\cell 
\pard\intbl\itap1\pardeftab720\ri0
\cf0 addr + (2 * aincr)\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrs\brdrw10\brdrcf5 \trbrdrr\brdrs\brdrw10\brdrcf5 
\clvertalt \clshdrawnil \clwWidth2970\clftsWidth3 \clbrdrt\brdrs\brdrw10\brdrcf5 \clbrdrl\brdrs\brdrw10\brdrcf5 \clbrdrb\brdrs\brdrw10\brdrcf5 \clbrdrr\brdrs\brdrw10\brdrcf5 \clpadl100 \clpadr100 \gaph\cellx4320
\clvertalt \clshdrawnil \clwWidth2970\clftsWidth3 \clbrdrt\brdrs\brdrw10\brdrcf5 \clbrdrl\brdrs\brdrw10\brdrcf5 \clbrdrb\brdrs\brdrw10\brdrcf5 \clbrdrr\brdrs\brdrw10\brdrcf5 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\ri0
\cf0 val[3]\cell 
\pard\intbl\itap1\pardeftab720\ri0
\cf0 addr + (3 * aincr)\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrs\brdrw10\brdrcf5 \trbrdrb\brdrs\brdrw10\brdrcf5 \trbrdrr\brdrs\brdrw10\brdrcf5 
\clvertalt \clshdrawnil \clwWidth2970\clftsWidth3 \clbrdrt\brdrs\brdrw10\brdrcf5 \clbrdrl\brdrs\brdrw10\brdrcf5 \clbrdrb\brdrs\brdrw10\brdrcf5 \clbrdrr\brdrs\brdrw10\brdrcf5 \clpadl100 \clpadr100 \gaph\cellx4320
\clvertalt \clshdrawnil \clwWidth2970\clftsWidth3 \clbrdrt\brdrs\brdrw10\brdrcf5 \clbrdrl\brdrs\brdrw10\brdrcf5 \clbrdrb\brdrs\brdrw10\brdrcf5 \clbrdrr\brdrs\brdrw10\brdrcf5 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\ri0
\cf0 :\cell 
\pard\intbl\itap1\pardeftab720\ri0
\cf0 :\cell \lastrow\row
\pard\pardeftab720\ri0
\cf0 \
Because 
\b val
\b0  is typically filled in and stored by calls on the device\'92s examine and deposit routines, respectively, the examine and deposit routines and 
\b fprint_sym
\b0  and
\b  fparse_sym
\b0  must agree on the expected width of items in 
\b val
\b0 , and on the alignment of 
\b addr
\b0 .  Further, if 
\b fparse_sym
\b0  wants to modify a storage unit narrower than 
\b awidth
\b0 , it must insert the new data into the appropriate entry in 
\b val
\b0  without destroying surrounding fields.\
\
The interpretation of switch values is arbitrary, but the following are used by existing VM\'92s:\
\
	switch				interpretation\
\
	-a				single character\
	-c				character string\
	-m				instruction mnemonic\
\
In addition, on input, a leading \'91 (apostrophe) is interpreted to mean a single character, and a leading \'93 (double quote) is interpreted to mean a character string.\
\pard\tx390\pardeftab720\li390\fi-390\ri0\sb240\sa60
\ls55\ilvl1
\i\b\fs24 \cf0 5.4	Optional Interfaces\
\pard\pardeftab720\ri0

\i0\b0\fs20 \cf0 \
For greater flexibility, SCP provides some optional interfaces that can be used to extend its command input, command processing, and command post-processing capabilities.  These interfaces are strictly optional and are off by default.  Using them requires intimate knowledge of how SCP functions internally and is not recommended to the novice VM writer.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls56\ilvl2
\fs24 \cf0 5.4.1	Once Only Initialization Routine\
\pard\pardeftab720\ri0

\fs20 \cf0 \
SCP defines a pointer (*
\b sim_vm_init
\b0 )(void).  This is a \'93weak global\'94; if no other module defines this value, it will default to NULL.  A VM requiring special initialization should fill in this pointer with the address of its special initialization routine:\
\
\pard\pardeftab720\ri0

\f4 \cf0 	void sim_special_init (void);\
	void (*sim_vm_init)(void) = &sim_special_init;\
\pard\pardeftab720\ri0

\f0 \cf0 \
The special initialization routine can perform any actions required by the VM.  If the other optional interfaces are to be used, the initialization routine can fill in the appropriate pointers; however, this can just as easily be done in the CPU reset routine.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls57\ilvl2
\fs24 \cf0 5.4.2	Address Input and Display\
\pard\pardeftab720\ri0

\fs20 \cf0 \
SCP defines a pointer t_addr *(
\b sim_vm_parse_addr
\b0 )(DEVICE *, char *, char **).  This is initialized to NULL.  If it is filled in by the VM, SCP will use the specified routine to parse addresses in place of its standard numerical input routine.  The calling sequence for the 
\b sim_vm_parse_addr
\b0  routine is:\
\
\pard\pardeftab720\li720\ri0
\cf0 t_addr 
\b sim_vm_parse_addr
\b0  (DEVICE *dptr, char *cptr, char **optr) \'96 parse the string pointed to by 
\i cptr
\i0  as an address for the device pointed to by 
\i dptr
\i0 .  o
\i ptr
\i0  points to the first character not successfully parsed.  If 
\i cptr
\i0  == 
\i optr
\i0 , parsing failed.\
\pard\pardeftab720\ri0
\cf0 \
SCP defines a pointer void *(
\b sim_vm_fprint_addr
\b0 )(FILE *, DEVICE *, t_addr).  This is initialized to NULL.  If it is filled in by the VM, SCP will use the specified routine to print addresses in place of its standard numerical output routine.  The calling sequence for the 
\b sim_vm_fprint_addr
\b0  routine is:\
\
\pard\pardeftab720\li720\ri0
\cf0 t_addr 
\b sim_vm_fprint_addr
\b0  (FILE *stream, DEVICE *dptr, t_addr addr) \'96 output address 
\i addr
\i0  to 
\i stream
\i0  in the format required by the device pointed to by 
\i dptr
\i0 .\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls58\ilvl2
\fs24 \cf0 5.4.3	Command Input and Post-Processing\
\pard\pardeftab720\ri0

\fs20 \cf0 \
SCP defines a pointer char* (
\b sim_vm_read
\b0 )(char *, int32 *, FILE *).  This is initialized to NULL.  If it is filled in by the VM, SCP will use the specified routine to obtain command input in place of its standard routine, read_line.  The calling sequence for the 
\b sim_vm_read
\b0  routine is:\
\
\pard\pardeftab720\li720\ri0
\cf0 char 
\b sim_vm_input
\b0  (char *buf, int32 *max, FILE *stream) \'96 read the next command line from 
\i stream
\i0  and store it in 
\i buf
\i0 , up to a maximum of 
\i max
\i0  characters\
\pard\pardeftab720\ri0
\cf0 \
The routine is expected to strip off leading whitespace characters and to return NULL on end of file.\
\
SCP defines a pointer void *(
\b sim_vm_post
\b0 )(t_bool from_scp).  This is initialized to NULL.  If filled in by the VM, SCP will call the specified routine at the end of every command.  This allows the VM to update any local state, such as a GUI console display.  The calling sequence for the vm_post routine is:\
\
\pard\pardeftab720\li720\ri0
\cf0 void 
\b sim_vm_postupdate
\b0  (t_bool from_scp) \'96 if called from SCP, the argument 
\i from_scp
\i0  is TRUE; otherwise, it is FALSE.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls59\ilvl2
\fs24 \cf0 5.4.4	VM-Specific Commands\
\pard\pardeftab720\ri0

\fs20 \cf0 \
SCP defines a pointer CTAB *
\b sim_vm_cmd
\b0 .  This is initialized to NULL.  If filled in by the VM, SCP interprets it as a pointer to SCP command table.  This command table is checked before user input is looked up in the standard command table.\
\
A command table is allocated as a contiguous array.  Each entry is defined with a 
\b sim_ctab
\b0  structure (typedef 
\b CTAB
\b0 ):\
\
\pard\pardeftab720\li720\ri0
\cf0 struct sim_ctab \{\
	char		*name;				/* name */\
	t_stat		(*action)();			/* action routine */\
	int32		arg;				/* argument */\
	char		*help;				/* help string */\
\pard\pardeftab720\li720\fi720\ri0
\cf0 \};\
\pard\pardeftab720\ri0
\cf0 \
If the first word of a command line matches ctab.name, then the action routine is called with the following arguments:\
\
\pard\pardeftab720\li720\ri0
\cf0 t_stat 
\b action_routine
\b0  (int32 arg, char *buf) \'96 process input string 
\i buf
\i0  based on optional argument 
\b arg
\b0 \
\pard\pardeftab720\ri0
\cf0 \
The string passed to the action routine starts at the first non-blank character past the command name.\
\pard\tx720\pardeftab720\li720\fi-720\ri0\sb240\sa60
\ls60\ilvl2
\fs24 \cf0 5.4.5	VM-Support for stepping over subroutine calls
\f1 \
\pard\pardeftab720\ri0

\fs20 \cf0 \
\pard\pardeftab720\ri0

\f0 \cf0 SCP can provide the ability to step over subroutine calls with the NEXT command.  In order for the NEXT command to work, the simulator must provide a VM specific routine which will identify whether the next instruction to be executed is a subroutine call and, if so to identify where to dynamically insert breakpoint(s) to stop instruction execution when the subroutine returns.  \
\
SCP defines a pointer t_bool *(
\f4  
\f0\b sim_vm_is_subroutine_call
\b0 )(t_addr **ret_addrs).  This is initialized to NULL.  If filled in by the VM, SCP will call the specified routine to determine where to dynamically place breakpoints to support the NEXT command.\
\
\pard\tx360\pardeftab720\li360\fi-360\ri0\sb240\sa60
\ls61\ilvl2
\b\fs28 \cf0 6.	Other SCP Facilities\
\pard\tx390\pardeftab720\li390\fi-390\ri0\sb240\sa60
\ls61\ilvl1
\i\fs24 \cf0 6.1	Terminal Input/Output Formatting Library\
\pard\pardeftab720\ri0

\i0\b0\fs20 \cf0 \
SIMH provides routines to convert ASCII input characters to the format expected VM, and to convert VM-supplied ASCII characters to C-standard format.  The routines are\
\
\pard\pardeftab720\li720\ri0
\cf0 int32 
\b sim_tt_inpcvt
\b0  (int32 c, uint32 mode) \'96 convert input character 
\i c
\i0  according to the 
\i mode 
\i0 specification and return the converted result (-1 if the character is not valid in the specified mode).\
\
int32 
\b sim_tt_outcvt
\b0  (int32 c, uint32 mode) \'96 convert output character 
\i c
\i0  according to the 
\i mode
\i0  specification and return the converted result (-1 if the character is not valid in the specified mode).\
\pard\pardeftab720\ri0
\cf0 \
The supported modes are:\
\
	TTUF_MODE_8B	8b mode; no conversion\
	TTUF_MODE_7B	7b mode; the high-order bit is masked off\
	TTUF_MODE_7P	7b printable mode; the high-order bit is masked off\
				In addition, on output, if the character is not printable,\
				-1 is returned\
	TTUF_MODE_UC	7b upper case mode; the high-order bit is masked off\
				In addition, lower case is converted to upper case\
				If the character is not printable, -1 is returned\
\
On input, TTUF_MODE_UC has an additional modifier, TTUF_MODE_KSR, which forces the high order bit to be set rather than cleared.\
\
The set of printable control characters is contained in the global bit-vector variable 
\b sim_tt_pchar
\b0 .  Each bit represents the character corresponding to the bit number (e.g., bit 0 represents NUL, bit 1 represents SOH, etc.).  If a bit is set, the corresponding control character is considered printable.  It initially contains the following characters: BEL, BS, HT, LF, and CR.  The set may be manipulated with these routines:\
\
\pard\pardeftab720\li720\ri0
\cf0 t_stat 
\b sim_set_pchar
\b0  (int32 flag, char *cptr) \'96 set 
\b sim_tt_pchar
\b0  to the value pointed to by 
\i cptr
\i0 ; return SCPE_2FARG if 
\i cptr
\i0  is null or points to a null string, or SCPE_ARG if the value cannot be converted or does not contain at least CR and LF.\
\
t_stat 
\b sim_show_pchar
\b0  (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, char *cptr) \'96 output the 
\b sim_tt_pchar
\b0  value to the stream 
\i st
\i0 .\
\pard\pardeftab720\ri0
\cf0 \
Note that the DEL character is always considered non-printable and will be suppressed in the UC and 7P modes.\
\
\pard\tx390\pardeftab720\li390\fi-390\ri0\sb240\sa60
\ls62\ilvl1
\i\b\fs24 \cf0 6.2	Terminal Multiplexer Emulation Library\
\pard\pardeftab720\ri0

\i0\b0\fs20 \cf0 \
SIMH supports the use of multiple terminals.  All terminals except the console are accessed via Telnet or serial ports on the host machine.  SIMH provides three supporting libraries for implementing multiple terminals: sim_tmxr.c (and its header file, sim_tmxr.h), which provide OS-independent support routines for terminal multiplexers; sim_serial.c (and its header file sim_serial.h), which provide OS-dependent serial I/O routines; and sim_sock.c (and its header file, sim_sock.h), which provide OS-dependent socket routines.  Sim_sock.c and sim_serial.c are implemented under Windows, VMS, UNIX, and MacOS.\
\
Two basic data structures define the multiple terminals.  Individual lines are defined by an array of  
\b tmln
\b0  structures (typedef 
\b TMLN
\b0 ):\
\
\pard\pardeftab720\li720\ri0
\cf0 struct tmln \{\
	int		conn;				/* line connected flag */\
\pard\pardeftab720\li720\fi720\ri0
\cf0 SOCKET	sock;				/* connection socket */\
\pard\pardeftab720\li720\ri0
\cf0 	char 		*ipad;				/* IP address */\
	SOCKET	master;				/* line specific master socket */\
	char		*port;				/* line specific listening port */\
	int32		sessions;			/* count of tcp connections received */\
	uint32		cnms;				/* connect  time ms */\
	int32		tsta;				/* Telnet state */\
	int32		rcve;				/* rcv enable */\
	int32		xmte;				/* xmt enable */\
	int32		dstb;				/* disable Tlnt bin */\
	int32		notelnet;			/* raw binary data (no telnet interpret) */\
	int32		rxbpr;				/* rcv buf remove */\
	int32		rxbpi;				/* rcv buf insert */\
	int32		rxcnt;				/* rcv count */\
	int32		txbpr;				/* xmt buf remove */\
	int32		txbpi;				/* xmt buf insert */\
	int32		txcnt;				/* xmt count */\
	int32		txdrp;				/* xmt drop count */\
 	int32		txbsz;				/* xmt buffer size */\
	int32		txbfd;				/* xmt buffered flag */\
	t_bool		modem_control;			/* line modem control support */\
	int32		modembits;			/* modem bits which are set */\
	FILE		*txlog;				/* xmt log file */\
	FILEREF	*txlogref;			/* xmt log file reference */\
	char		*txlogname;			/* xmt log file name */\
	char		rxb[TMXR_MAXBUF];		/* rcv buffer */\
	char		rbr[TMXR_MAXBUF];		/* rcv break */\
	char		*txb;				/* xmt buffer */\
	TMXR		*mp;				/* back pointer to mux */\
	char		*serconfig;			/* line config */\
	SERHANDLE	serport;				/* serial port handle */\
	t_bool		ser_connect_pending;		/* serial connection notice pending */\
	SOCKET	connecting;			/* Outgoing socket while connecting */\
	char		*destination;			/* Outgoing destination address:port */\
	UNIT		*uptr;				/* input polling unit -default to mp->uptr */\
	UNIT		*o_uptr;				/* output polling unit \'96default to lp->uptr */\
	\};\
\pard\pardeftab720\ri0
\cf0 \
The fields are the following:\
\
	
\b conn
\b0 		connection flag (0 = disconnected)\
	
\b sock
\b0 		connection socket\
	ipad		IP address of remote end of connection\
	
\b master
\b0 		optional line specific listening socket\
	
\b port
\b0 		optional line specific listening port\
	
\b sessions
\b0 	count of tcp connections received\
	
\b cnms
\b0 		connect time\
	
\b tsta
\b0 		Telnet state\
	
\b rcve
\b0 		receive enable flag (0 = disabled)\
	
\b xmte
\b0 		transmit flow control flag (0 = transmit disabled)\
	
\b dstb
\b0 		Telnet bin mode disabled\
	
\b rxbp
\b0 r		receive buffer remove pointer\
	
\b rxbpi
\b0 		receive buffer insert pointer\
	
\b rxcnt
\b0 		receive count\
	
\b txbpr
\b0 		transmit buffer remove pointer\
	
\b txbpi
\b0 		transmit buffer insert pointer\
	
\b txcnt
\b0 		transmit count\
	
\b txlog
\b0 		pointer to log file descriptor\
	
\b txlogname
\b0 	pointer to log file name\
\pard\pardeftab720\fi720\ri0

\b \cf0 rxb
\b0 		receive buffer\

\b rbr
\b0 		receive buffer break flags\
\pard\pardeftab720\ri0
\cf0 	
\b txb
\b0 		transmit buffer\
\
The overall set of extra terminals is defined by the 
\b tmxr
\b0  structure (typedef 
\b TMXR
\b0 ):\
\
\pard\pardeftab720\li720\ri0
\cf0 struct tmxr \{\
	int32		lines;				/* # lines */\
	char		*port;				/* listening port */\
	SOCKET	master;				/* master socket */\
	TMLN		*ldsc;				/* pointer to line descriptors */\
	int32		*lnorder;			/* line connection order */\
	DEVICE	*dptr;				/* multiplexer device */\
	UNIT		*uptr;				/* polling unit (connection) */\
	char 		logfiletmpl[FILENAMEMAX];	/* template logfile name */\
	int23		buffered;			/* Buffered line behavior and buffer size*/\
	int32		sessions;			/* count of tcp connections received */\
	uint32		last_poll_time;			/* time of last connection poll */\
	t_bool		notelnet;			/* default telnet capability for incoming connections */\
	t_bool		modem_control;			/* multiplexer supports modem control behaviors */\
	\};\
\pard\pardeftab720\ri0
\cf0 \
The fields are the following:\
\
	
\b lines
\b0 		number of lines (constant)\
	
\b port
\b0 		master listening port (specified by ATTACH command)\
	
\b master
\b0 		master listening socket (filled in by ATTACH command)\
	
\b ldsc
\b0 		array of line descriptors\
\pard\pardeftab720\li2160\fi-1440\ri0

\b \cf0 lnorder
\b0 		array of line numbers in order of connection sequence, or NULL if user-defined connection order is not required\

\b dptr
\b0 		pointer to the multiplexer\'92s DEVICE structure, or NULL if the device is to be derived from the UNIT passed to the attach call.\

\b uptr
\b0 		the UNIT passed to the attach call.\

\b logfiletmpl
\b0 	template logfile name used to create names for per line log filesl.\

\b buffered
\b0 	Buffered line behaviors enabled flag and the size of the line buffer.\

\b sessions
\b0 	count of tcp connections received on the master socket.\

\b last_poll_time
\b0 	time of last connection poll.\

\b notelnet
\b0 	default telnet capability for tcp connections.\

\b modem_control
\b0 	flag indicating that multiplexer supports full modem control behaviors.\
\pard\pardeftab720\ri0
\cf0 \
\
\pard\pardeftab720\li2160\fi-1440\ri0
\cf0 \
\pard\pardeftab720\ri0
\cf0 \
The number of elements in the 
\b ldsc
\b0  and 
\b lnorder
\b0  arrays must equal the value of the 
\b lines
\b0  field.  Set 
\b lnorder
\b0  to NULL if the connection order feature is not needed.  If the first element of the 
\b lnorder
\b0  array is \'961, then the default ascending sequential connection order is used.  Set 
\b dptr
\b0  to NULL if the device should be derived from the unit passed to the 
\b tmxr_attach
\b0  call.\
\
Library sim_tmxr.c provides the following routines to support Telnet and Serial port-based terminals:\
\
\pard\pardeftab720\li720\ri0
\cf0 int32 
\b tmxr_poll_conn
\b0  (TMXR *mp) \'96 poll for a new connection to the terminals described by 
\i mp
\i0 .  If there is a new connection, the routine resets all the line descriptor state (including receive enable) and returns the line number (index to line descriptor) for the new connection.  If there isn\'92t a new connection, the routine returns \'961.\
\
void 
\b tmxr_reset_ln
\b0  (TMLN *lp) \'96 reset the line described by 
\i lp
\i0 .  The connection is closed and all line descriptor state is reset.\
\
int32 
\b tmxr_getc_ln
\b0  (TMLN *lp) \'96 return the next available character from the line described by 
\i lp
\i0 .  If a character is available, the return value is:\
\
\pard\pardeftab720\li720\ri0

\f4 \cf0 	(1 << TMXR_V_VALID) | character\
\pard\pardeftab720\li720\ri0

\f0 \cf0 \
If a BREAK occurred on the line, SCPE_BREAK will be ORed into the return variable.  If no character is available, the return value is 0.\
\
void 
\b tmxr_poll_rx
\b0  (TMXR *mp) \'96 poll for input available on the terminals described by 
\i mp
\i0 . \
\
void 
\b tmxr_rqln
\b0  (TMLN *lp) \'96 return the number of characters in the receive queue of the line described by 
\i lp
\i0 .\
\
t_stat 
\b tmxr_putc_ln
\b0  (TMLN *lp, int32 chr) \'96 output character 
\i chr 
\i0 to the line described by 
\i lp
\i0 .  Possible errors are SCPE_LOST (connection lost) and SCPE_STALL (connection backlogged).\
\
void 
\b tmxr_poll_tx
\b0  (TMXR *mp) \'96 poll for output complete on the terminals described by 
\i mp
\f1\i0 .\

\f0 \
void 
\b tmxr_tqln
\b0  (TMLN *lp) \'96 return the number of characters in the transmit queue of the line described by 
\i lp
\i0 .\
\
void 
\b tmxr_send_buffered_data
\b0  (TMLN *lp) \'96 flush any buffered data for the line described by 
\i lp
\i0 .\
\
t_stat 
\b tmxr_attach
\b0  (TMXR *mp, UNIT *uptr, char *cptr) \'96 attach the port contained in character string 
\i cptr
\i0  to the terminals described by 
\i mp
\i0  and unit 
\i uptr
\i0 .\
\
t_stat 
\b tmxr_open_master
\b0  (TMXR *mp, char *cptr) \'96 associate the port contained in character string 
\i cptr
\i0  to the terminals described by 
\i mp
\i0 .  This routine is a subset of 
\b tmxr_attach
\b0 .\
\
t_stat 
\b tmxr_detach
\b0  (TMXR *mp, UNIT *uptr) \'96 detach all connections for the terminals described by 
\i mp
\i0  and unit 
\i uptr
\f1\i0 .\
\

\f0 t_stat 
\b tmxr_close_master
\b0  (TMXR *mp) \'96 close the master port for the terminals described by 
\i mp
\i0 .  This routine is a subset of
\b  tmxr_detach
\f1\b0 .\

\f0 \
t_stat 
\b tmxr_ex
\b0  (t_value *vptr, t_addr addr, UNIT *uptr, int32 sw) \'96 stub examine routine, needed because the extra terminals are marked as attached; always returns an error.\
\
t_stat 
\b tmxr_dep
\b0  (t_value val, t_addr addr, UNIT *uptr, int32 sw) \'96 stub deposit routine, needed because the extra terminals are marked as detached; always returns an error.\
\pard\pardeftab720\li360\ri0
\cf0 \
\pard\pardeftab720\li360\fi360\ri0
\cf0 void 
\b tmxr_msg
\b0  (SOCKET sock, char *msg) \'96 output character string 
\i msg
\i0  to socket sock.\
\
void 
\b tmxr_linemsg
\b0  (TMLN *lp, char *msg) \'96 output character string 
\i msg
\i0  to line 
\i lp
\i0 .\
\
void 
\b tmxr_linemsgf
\b0  (TMLN *lp, const *fmt, ,,,) \'96 output formatted 
\i msg
\i0  to line 
\i lp
\i0 .\
\
\pard\pardeftab720\li720\ri0
\cf0 void 
\b tmxr_fconns
\b0  (FILE *st, TMLN *lp, int32 ln) \'96 output connection status to stream 
\i st
\i0  for the line described by 
\i lp
\i0 .  If 
\i ln
\i0  is >= 0, preface the output with the specified line number.\
\
void 
\b tmxr_fstats
\b0  (FILE *st, TMLN *lp, int32 ln) \'96 output connection statistics to stream 
\i st
\i0  for the line described by 
\i lp
\i0 .  If 
\i ln
\i0  is >= 0, preface the output with the specified line number.\
tstat 
\b tmxr_set_log
\b0  (UNIT *uptr, int32 val, char *cptr, void *mp) \'96 enable logging of a line of the multipleser described by mp to the filename pointed to by cptr.  If uptr is NULL, then val indicates the line number; otherwise, the unit number within the associated device implies the line number.  This function may be used as an MTAB validation routine.\
\
tstat 
\b tmxr_set_nolog
\b0  (UNIT *uptr, int32 val, char *cptr, void *mp) \'96 disable logging of a line of the multipleser described by mp to the filename pointed to by cptr.  If uptr is NULL, then val indicates the line number; otherwise, the unit number within the associated device implies the line number.  This function may be used as an MTAB validation routine.\
\
tstat 
\b tmxr_show_log
\b0  (FILE *st, UNIT *uptr, int32 val, void *mp) \'96 outputs the logging status of a line of the multiplexer described by mp to stream st.  If uptr is NULL, then val indicates the line number; otherwise, the unit number within the associated device implies the line number.  This function may be used as an MTAB display routine.\
\pard\pardeftab720\ri0
\cf0 \
\pard\pardeftab720\li720\ri0
\cf0 t_stat 
\b tmxr_dscln
\b0  (UNIT *uptr, int32 val, char *cptr, void *mp) \'96 parse the string pointed to by 
\i cptr
\i0  for a decimal line number.  If the line number is valid, disconnect the specified line in the terminal multiplexer described by 
\i mp
\i0 .  The calling sequence allows 
\b tmxr_dscln
\b0  to be used as an MTAB processing routine.  A line connected via a tcp session will be disconnected, a line connected to a serial port will be closed if the sim_switches \'96C flag is enabled when the routine is called, otherwise a serial port will have DTR dropped for 500ms and raised again.\
\
t_stat 
\b tmxr_set_lnorder
\b0  (UNIT *uptr, int32 val, char *cptr, void *desc) \'96 set the line connection order array associated with the TMXR structure pointed to by 
\i desc
\i0 .  The string pointed to by 
\i cptr
\i0  is parsed for a semicolon-delimited list of ranges.  Ranges are of the form:\
\
\pard\pardeftab720\li3600\fi-2160\ri0

\f4 \cf0 line1-line2	ascending sequence from 
\f5\b line1
\f4\b0  to 
\f5\b line2
\f4\b0 \
line1/length	ascending sequence from 
\f5\b line1
\f4\b0  to 
\f5\b line1
\f4\b0 +
\f5\b length
\f4\b0 -1\
ALL	ascending sequence of all lines defined by the multiplexer\
\pard\pardeftab720\li720\ri0

\f0 \cf0 \
The line order array must provide an int32 element for each line.  The calling sequence allows 
\b tmxr_set_lnorder
\b0  to be used as an MTAB processing routine.\
\
t_stat 
\b tmxr_show_lnorder
\b0  (FILE *st, UNIT *uptr, int32 val, void *desc) \'96 output the line connection order associated multiplexer (TMXR *) 
\i desc
\f1\i0  
\f0 to stream 
\i st
\i0 .  The order is rendered as a semicolon-delimited list of ranges.  The calling sequence allows 
\b tmxr_show_lnorder
\b0  to be used as an MTAB processing routine.\
\
t_stat 
\b tmxr_show_summ
\b0  (FILE *st, UNIT *uptr, int32 val, void *desc) \'96 outputs the summary status of the multiplexer (TMXR *) 
\i desc
\i0  to stream 
\i st
\i0 .\
\
t_stat 
\b tmxr_show_cstat
\b0  (FILE *st, UNIT *uptr, int32 val, void *desc) \'96 outputs either the connections (val = 1) or the statistics (val = 0) of the multiplexer (TMXR *) 
\i desc
\i0  to stream 
\i st
\i0 . Also checks for multiplexer not attached, or all lines disconnected.\
\
t_stat 
\b tmxr_show_lines
\b0  (FILE *st, UNIT *uptr, int32 val, void *desc) \'96 outputs the number of lines in the terminal multiplexer (TMXR *) I to stream I.\
\pard\pardeftab720\li720\ri0

\f1 \cf0 \
\pard\pardeftab720\li720\ri0

\f0 \cf0 t_stat 
\b tmxr_set_modem_control_passthru
\b0  (TMXR *mp) \'96 Enables modem control passthru behaviors, and disables internal manipulation of DTR (&RTS) by tmxr apis.  Enables the tmxr_set_get_modem_bits and tmxr_set_config_line apis.\
\
t_stat 
\b tmxr_clear_modem_control_passthru
\b0  (TMXR *mp) \'96 Disables modem control passthru behaviors, and enables internal manipulation of DTR (&RTS) by tmxr apis.  Disables the tmxr_set_get_modem_bits and tmxr_set_config_line apis.\
\
t_stat 
\b tmxr_set_get_modem_bits
\b0  (TMLN *lp, int32 bits_to_set, int32 bits_to_clear, int32 *incoming_bits) \'96 For a line connected to a serial port on a TMXR device with modem_control_passthru enabled, then the bits_to_set and/or bits_to_clear (DTR and RTS) are changed and if incoming_bits is not NULL, then the current modem bits are returned (DCD,RNG,CTS, DSR).
\f1 \
\

\f0 t_stat 
\b tmxr_set_config_line
\b0  (TMLN *lp, char *config) \'96 sets the line configuration (speed, parity, character size, stopbits) on a serial port.  Config is a string of the form: 9600-8N1.\
\
t_stat 
\b tmxr_set_line_unit
\b0  (TMXR *mp, int line, UNIT *uptr) \'96 Declare which unit polls for input on a given line (only needed if the input polling unit is different than the unit provided when the multiplexer was attached.
\f1 \
\pard\pardeftab720\ri0
\cf0 \
\pard\pardeftab720\li720\ri0
\cf0 \
\pard\pardeftab720\ri0

\f0 \cf0 The OS dependent serial I/O and socket routines should not need to be accessed by the terminal simulators.\
\pard\pardeftab720\li720\ri0
\cf0 \
\pard\tx390\pardeftab720\li390\fi-390\ri0\sb240\sa60
\ls63\ilvl1
\i\b\fs24 \cf0 6.3	Magnetic Tape Emulation Library\
\pard\pardeftab720\ri0

\i0\b0\fs20 \cf0 \
SIMH supports the use of emulated magnetic tapes.  Magnetic tapes are emulated as disk files containing both data records and metadata markers; the format is fully described in the paper \'93SIMH Magtape Representation and Handling\'94.  SIMH provides a supporting library, sim_tape.c (and its header file, sim_tape.h), that abstracts handling of magnetic tapes.  This allows support for multiple tape formats, without change to magnetic device simulators.\
\
The magtape library does not require any special data structures.  However, it does define some additional unit flags:\
\
	MTUF_WLK		unit is write locked\
\
If magtape simulators need to define private unit flags, those flags should begin at bit number MTUF_V_UF instead of UNIT_V_UF.  The magtape library maintains the current magtape position in the 
\b pos
\b0  field of the 
\b UNIT
\b0  structure.\
\
Library sim_tape.c provides the following routines to support emulated magnetic tapes:\
\
\pard\pardeftab720\li720\ri0
\cf0 t_stat 
\b sim_tape_attach
\b0  (UNIT *uptr, char *cptr) \'96 Attach tape unit 
\i uptr 
\i0 to file 
\i cptr
\i0 .  Tape \
Simulators should call this routine, rather than the standard attach_unit routine, to allow for future expansion of format support.\
\
t_stat 
\b sim_tape_detach
\b0  (UNIT *uptr) \'96 Detach tape unit 
\i uptr
\i0  from its current file.\
\
t_stat 
\b sim_tape_set_fmt
\b0  (UNIT *uptr, int32 val, char *cptr, void *desc) \'96 Set the tape format for unit 
\i uptr
\i0  to the format specified by string 
\i cptr
\i0 .\
\
t_stat 
\b sim_tape_show_fmt
\b0  (FILE *st, UNIT *uptr, int32 val, void *desc) \'96 Write the tape format for unit 
\i uptr
\i0  to the file specified by descriptor 
\i st
\i0 .\
\
t_stat 
\b sim_tape_set_capac
\b0  (UNIT *uptr, int32 val, char *cptr, void *desc) \'96 Set the tape capacity for unit 
\i uptr
\i0  to the capacity, in MB, specified by string 
\i cptr
\i0 .\
\
t_stat 
\b sim_tape_show_capac
\b0  (FILE *st, UNIT *uptr, int32 val, void *desc) \'96 Write the capacity for unit 
\i uptr
\i0  to the file specified by descriptor 
\i st
\i0 .\
\pard\pardeftab720\li720\ri0

\f1 \cf0 \
\pard\pardeftab720\li720\ri0

\f0 \cf0 t_stat 
\b sim_tape_rdrecf
\b0  (UNIT *uptr, uint8 *buf, t_mtrlnt *tbc, t_mtrlnt max) \'96 Forward read the next record on unit 
\i uptr
\i0  into buffer 
\i buf
\i0  of size 
\i max
\i0 .  Return the actual record size in 
\i tbc
\f1\i0 .\

\f0 \
t_stat 
\b sim_tape_rdrecr
\b0  (UNIT *uptr, uint8 *buf, t_mtrlnt *tbc, t_mtrlnt max) \'96 Reverse read the next record on unit 
\i uptr
\i0  into buffer 
\i buf
\i0  of size 
\i max
\i0 .  Return the actual record size in 
\i tbc
\i0 .  Note that the record is returned in forward order, that is, byte 0 of the record is stored in buf[0], and so on.\
\
t_stat 
\b sim_tape_wrrecf
\b0  (UNIT *uptr, uint8 buf, t_mtrlnt tbc) \'96 Write buffer 
\i uptr
\i0  of size 
\i tbc
\i0  as the next record on unit 
\i uptr
\i0 .\
\
t_stat 
\b sim_tape sprecf
\b0  (UNIT *uptr, t_mtrlnt *tbc) \'96 Space unit 
\i uptr
\i0  forward one record.  The size of the record is returned in 
\i tbc
\i0 .\
\
t_stat 
\b sim_tape_sprecr
\b0  (UNIT *uptr, t_mtrlnt *tbc) \'96 Space unit 
\i uptr
\i0  reverse one record.  The size of the record is returned in tbc.\
\
t_stat 
\b sim_tape_wrtmk
\b0  (UNIT *uptr) \'96 Write a tape mark on unit 
\i uptr
\i0 .\
\
t_stat 
\b sim_tape_wreom
\b0  (UNIT *uptr) \'96 Write an end-of-medium marker on unit 
\i uptr
\i0  (this effectively erases the rest of the tape).\
\
t_stat 
\b sim_tape_wrgap
\b0  (UNIT *uptr, uint32 gaplen, uint32 bpi) \'96 Write an erase gap on unit 
\i uptr
\i0  of 
\i gaplen
\i0  tenths of an inch in length at a tape density of 
\i bpi
\i0  bits per inch.\
\
t_stat 
\b sim_tape_rewind
\b0  (UNIT *uptr) \'96 Rewind unit 
\i uptr
\i0 .  This operation succeeds whether or not the unit is attached to a file.\
\
t_stat 
\b sim_tape_reset
\b0  (UNIT *uptr) \'96 Reset unit 
\i uptr
\i0 .  This routine should be called when a tape unit is reset.\
\
t_bool 
\b sim_tape_bot
\b0  (UNIT *uptr) \'96 Return TRUE if unit 
\i uptr
\i0  is at beginning-of-tape.\
\
t_bool 
\b sim_tape wrp
\b0  (UNIT *uptr) \'96 Return TRUE if unit 
\i uptr
\i0  is write-protected.\
\
t_bool 
\b sim_tape_eot
\b0  (UNIT *uptr) \'96 Return TRUE if unit 
\i uptr
\i0  has exceed the capacity specified of the specified unit (kept in uptr->capac).\
\pard\pardeftab720\ri0
\cf0 \
\pard\pardeftab720\ri0

\b \cf0 Sim_tape_attach
\b0 , 
\b sim_tape_detach, sim_tape_set_fmt,
\b0  
\b sim_tape_show_fmt, sim_tape_set_capac
\b0 , and 
\b sim_tape_show_capac
\b0  return standard SCP status codes; the other magtape library routines return return private codes for success and failure.  The currently defined magtape status codes are:\
\
	MTSE_OK		operation successful\
	MTSE_UNATT		unit is not attached to a file\
	MTSE_FMT		unit specifies an unsupported tape file format\
	MTSE_IOERR		host operating system I/O error during operation\
	MTSE_INVRL		invalid record length (exceeds maximum allowed)\
	MTSE_RECE		record header contains error flag\
	MTSE_TMK		tape mark encountered\
	MTSE_BOT		beginning of tape encountered during reverse operation\
	MTSE_EOM		end of medium encountered\
	MTSE_WRP		write protected unit during write operation\
\

\b Sim_tape_set_fmt,
\b0  
\b sim_tape_show_fmt, sim_tape_set_capac, 
\b0 and 
\b sim_tape_show_capac
\b0  should be referenced by an entry in the tape device\'92s modifier list, as follows:\
\
\pard\pardeftab720\ri0

\f4 \cf0 	MTAB tape_mod[] = \{\
\pard\pardeftab720\li720\fi720\ri0
\cf0 \{ MTAB_XTD|MTAB_VDV, 0, \'93FORMAT\'94, \'93FORMAT\'94,\
\pard\pardeftab720\ri0
\cf0 	  	  &sim_tape_set_fmt, &sim_tape_show_fmt, NULL \},\
\pard\pardeftab720\li720\fi720\ri0
\cf0 \{ MTAB_XTD|MTAB_VUN, 0, \'93CAPACITY\'94, \'93CAPACITY\'94,\
\pard\pardeftab720\li1440\ri0
\cf0   &sim_tape_set_capac, &sim_tape_show_capac, NULL \}, \'85\
\pard\pardeftab720\li720\fi720\ri0
\cf0 \};\
\pard\tx390\pardeftab720\li390\fi-390\ri0\sb240\sa60
\ls64\ilvl1
\f0\i\b\fs24 \cf0 6.4	Disk Emulation Library\
\pard\pardeftab720\ri0

\i0\b0\fs20 \cf0 \
SIMH supports the use of disk drives.  Disk drives as disk files containing both data records and metadata markers; the format is fully described in the paper \'93SIMH Magtape Representation and Handling\'94.  SIMH provides a supporting library, sim_disk.c (and its header file, sim_disk.h), that abstracts handling of disk drives tapes.  This allows support for disk formats, without change to magnetic device simulators.\
\
The disk library does not require any special data structures.  However, it does define some additional unit flags:\
\
	DKUF_WLK		unit is write locked\
\
If magtape simulators need to define private unit flags, those flags should begin at bit number DKUF_V_UF instead of UNIT_V_UF.  The disk library maintains the current magtape position in the 
\b pos
\b0  field of the 
\b UNIT
\b0  structure.\
Library sim_tape.c provides the following routines to support emulated magnetic tapes:\
\
\pard\pardeftab720\li720\ri0
\cf0 t_stat 
\b sim_disk_attach
\b0  (UNIT *uptr, char *cptr, size_t sector_size, size_t xfer_element_size, t_bool dontautosize, uint32 debugbit, const char *drivetype, uint32 pdp11_tracksize, int completion_delay) \'96 Attach disk unit 
\i uptr 
\i0 to file 
\i cptr
\i0 .  Disk Simulators should call this routine, rather than the standard attach_unit routine, \
\
t_stat 
\b sim_disk_detach
\b0  (UNIT *uptr) \'96 Detach disk unit 
\i uptr
\i0  from its current file.\
\
t_stat 
\b sim_disk_set_fmt
\b0  (UNIT *uptr, int32 val, char *cptr, void *desc) \'96 Set the disk format for unit 
\i uptr
\i0  to the format specified by string 
\i cptr
\i0 .\
\
t_stat 
\b sim_disk_show_fmt
\b0  (FILE *st, UNIT *uptr, int32 val, void *desc) \'96 Write the disk format for unit 
\i uptr
\i0  to the file specified by descriptor 
\i st
\i0 .\
\
t_stat 
\b sim_disk_set_capac
\b0  (UNIT *uptr, int32 val, char *cptr, void *desc) \'96 Set the disk capacity for unit 
\i uptr
\i0  to the capacity, in MB, specified by string 
\i cptr
\i0 .\
\
t_stat 
\b sim_disk_show_capac
\b0  (FILE *st, UNIT *uptr, int32 val, void *desc) \'96 Write the capacity for unit 
\i uptr
\i0  to the file specified by descriptor 
\i st
\i0 .\
\pard\pardeftab720\li720\ri0

\f1 \cf0 \
\pard\pardeftab720\li720\ri0

\f0 \cf0 t_stat 
\b sim_disk_rdsect
\b0  (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectsread, , t_seccnt *sectstoread) \'96 Read up to sectstoread sectors from sector number lba on unit 
\i uptr
\i0  into buffer 
\i buf
\i0 .  Return the number of sectors read in 
\i sectsread
\f1\i0 .\

\f0 \
t_stat 
\b sim_disk_rdsect_a
\b0  (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectsread, , t_seccnt *sectstoread, DISK_PCALLBACK callback) \'96 Read up to sectstoread sectors from sector number lba on unit 
\i uptr
\i0  into buffer 
\i buf asynchronously
\i0 .  Return the number of sectors read in 
\i sectsread
\i0 , and call callback routine on completion.
\f1 \

\f0 \
t_stat 
\b sim_disk_wrsect
\b0  (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectswritten, , t_seccnt *sectstowrite) \'96 Write sectstowrite sectors from buffer buf to disk sector number lba on unit uptr.  Return the number of sectors written in 
\i sectswritten
\f1\i0 .\

\f0 \
t_stat 
\b sim_disk_wrsect_a
\b0  (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectswritten, , t_seccnt *sectstowrite, DISK_PCALLBACK callback) \'96 Write sectstowrite sectors from buffer buf to disk sector number lba on unit 
\i uptr
\i0  
\i asynchronously
\i0 .  Return the number of sectors written in 
\i sectswritten
\i0 , and call callback routine on completion.\
\
t_stat 
\b sim_disk_unload
\b0  (UNIT *uptr) \'96 Unload or detach a disk as needed.
\f1 \

\f0 \
t_stat 
\b sim_disk_set_asynch
\b0  (UNIT *uptr, int latency) \'96 Enable asynchronouos operation for I/O to disk unit uptr.\
\
t_stat 
\b sim_disk_clr_asynch
\b0  (UNIT *uptr, int latency) \'96 Disable asynchronouos operation for I/O to disk unit uptr.\
\
t_stat 
\b sim_disk_reset
\b0  (UNIT *uptr) \'96 Reset unit 
\i uptr
\i0 .  This routine should be called when a tape unit is reset.
\f1 \
\

\f0 t_bool 
\b sim_disk_isavailable 
\b0 (UNIT *uptr) \'96 Check to see if disk is available for I/O, return TRUE if so.\
\
t_bool 
\b sim_disk_isavailable_a 
\b0 (UNIT *uptr, DISK_PCALLBACK callback) \'96 Check to see if disk is available for I/O asynchronously.  Return TRUE if so.\
\
\pard\pardeftab720\li720\ri0

\f1 \cf0 t_bool 
\b sim_disk_wrp
\b0  (UNIT *uptr) \'96 
\f0 Return TRUE if unit 
\i uptr
\i0  is write-protected.\

\f1 \
\pard\pardeftab720\li720\ri0

\f0 \cf0 t_addr 
\b sim_disk_size
\b0  (UNIT *uptr) \'96 get disk size\
\
\pard\pardeftab720\ri0

\b \cf0 Sim_disk_attach
\b0 , 
\b sim_disk_detach, sim_disk_set_fmt,
\b0  
\b sim_disk_show_fmt, sim_disk_set_capac
\b0 , and 
\b sim_tape_disk_capac
\b0  return standard SCP status codes; the other disk library routines return return private codes for success and failure.  Success status is DKSE_OK and any other value is an error.  Errno usually will have the appropriate error code:\
\
	DKSE_OK		operation successful\
\
\

\b Sim_disk_set_fmt,
\b0  
\b sim_disk_show_fmt, sim_disk_set_capac, 
\b0 and 
\b sim_disk_show_capac
\b0  should be referenced by an entry in the disk device\'92s modifier list, as follows:\
\
\pard\pardeftab720\ri0

\f4 \cf0 	MTAB tape_mod[] = \{\
\pard\pardeftab720\li720\fi720\ri0
\cf0 \{ MTAB_XTD|MTAB_VDV, 0, \'93FORMAT\'94, \'93FORMAT\'94,\
\pard\pardeftab720\ri0
\cf0 	  	  &sim_disk_set_fmt, &sim_disk_show_fmt, NULL \},\
\pard\pardeftab720\li720\fi720\ri0
\cf0 \{ MTAB_XTD|MTAB_VUN, 0, \'93CAPACITY\'94, \'93CAPACITY\'94,\
\pard\pardeftab720\li1440\ri0
\cf0   &sim_disk_set_capac, &sim_disk_show_capac, NULL \}, \'85\
\pard\pardeftab720\li720\fi720\ri0
\cf0 \};\
\pard\pardeftab720\ri0

\f0 \cf0 \
\pard\tx390\pardeftab720\li390\fi-390\ri0\sb240\sa60
\ls65\ilvl1
\i\b\fs24 \cf0 6.5	Breakpoint Support\
\pard\pardeftab720\ri0

\i0\b0\fs20 \cf0 \
SCP provides underlying mechanisms to track multiple breakpoints of different types.  Most VM\'92s implement at least instruction execution breakpoints (type E); but a VM might also allow for break on read (type R), write (type W), and so on.  Up to 26 25 different breakpoint types, identified by the letters A,B and D through Z, are supported.\
\
The VM interface to the breakpoint package consists of three variables and one subroutine:\
\
\pard\pardeftab720\li720\ri0

\b \cf0 sim_brk_types
\b0  \'96 initialized by the VM (usually in the CPU reset routine) to a mask of all supported breakpoints.\
\
\pard\pardeftab720\ri0
\cf0 	
\b sim_brk_dflt
\b0  \'96 initialized by the VM to the mask for the default breakpoint type.\
\
\pard\pardeftab720\li720\ri0

\b \cf0 sim_brk_summ
\b0  \'96 maintained by SCP, providing a bit mask summary of whether any breakpoints of a particular type have been defined.\
\pard\pardeftab720\ri0
\cf0 \
If the VM only implements one type of breakpoint, then 
\b sim_brk_summ
\b0  is non-zero if any breakpoints are set.\
\
To test whether a breakpoint of particular type is set for an address, the VM calls\
\
\pard\pardeftab720\li720\ri0
\cf0 uint32l 
\b sim_brk_test
\b0  (t_addr addr, int32 typ) \'96 test to see if a breakpoint of type 
\i typ
\i0  is set for location 
\i addr
\i0 ; returns 0 if no, and a bit mask of all breakpoints that match typ if yes\
\pard\pardeftab720\ri0
\cf0 \
Because 
\b sim_brk_test
\b0  can be a lengthy procedure, it is usually prefaced with a test of 
\b sim_brk_summ
\b0 :\
\
	
\f4 if (sim_brk_summ && sim_brk_test (PC, SWMASK (\'91E\'92))) \{\
\pard\pardeftab720\li720\fi720\ri0
\cf0 <execution break> \}\
\pard\pardeftab720\ri0

\f0 \cf0 \
To accommodate more complex breakpoint schemes, SCP implements a concept of breakpoint spaces.  Each breakpoint space is an orthogonal collection of breakpoints that are tracked independently.  For example, in a symmetric multiprocessing simulation, breakpoint spaces could be assigned to each CPU to distinguish E (execution) breakpoints for different processors.  SCP supports up to 64 16 breakpoint spaces; the space is specified by bits <31:2628> of the 
\i typ
\i0  argument to 
\b sim_brk_test
\b0 .  By default, there is only one breakpoint space (space 0).\
\
}